todo:
	глянуть ещё на формулу
	в разрезе, скажем,
	малых t1, t2, t3, t4

как доказать,
что не бывает ровно 1 oriented вершины?
и как доказать,
что если в решении 0 oriented вершин, то
	в каждом паросочетании - чётное число rich рёбер
	они парами ходят или как? (нет, наивно парами явно не ходят)
	может цепи можно реально склеить друг с другом?
		(можно склеить, но я не знаю что из этого вытащить
		правда я склеил по вершинам)

	причём может их надо склеивать без противоположных пар рёбер?
		если это rich ребро - это невозможно сделать

	ну может надо как-то по-другому клеить
	не рёбрами, а вершинами
		каждая вершина превращается в 3 ребра
		и теперь всё это клеим

	done: надо проверить, по идее работает такая склейка
	а граф тогда превращается в line graph
	а o6c4c тогда превращается в o6cdc для line graph'а

	6c4c вроде всегда превращается в 6cdc для line graph'а

	We prove that the Petersen colouring conjecture implies
	a conjecture of Markström saying that
	the line graph of every bridgeless cubic graph is
	decomposable into cycles of even length.

	Problem 3.8. Is the Petersen graph the only snark which does not have an even cycle double cover?
	(чуваки проверили это утверждение до 28 вершин)

	и да, проблема проверки мелких снарков в том, что:
	All snarks on n <= 28 vertices have oddness 2

	так, энивей!

	вот я склеил, получил line graph с хитрым o6cdc, где
		в каждом слое каждая вершина степени 0 или 2, не бывает 4,
		и ещё в каждой вершине запрещены пары рёбер

	что мне теперь делать с rich рёбрами в паросочетании?
	рёбра переходят в вершины этого line graph
	ничего мне эта конструкция не прояснила, если честно

	пример, когда or == 0:

rich edges: 2 5 10 16 18 19 23 28 31 35
rich edges: 2 8 11 12 14 23 30 35
rich edges: 1 4 6 10 15 17 21 22 26 30 32 34
rich edges: 1 5 6 9 13 14 18 22 24 34
rich edges: 4 8 9 12 16 21 24 26 32 33
rich edges: 11 13 15 17 19 28 31 33

попробую разбить на пары:
2, 23
1, 6
4, 32
9, 24
8, 12
5, 18
22, 34
21, 26
19, 28
15, 17
не, не разбивается на пары
rich edges: 10 16 31 35
rich edges: 11 14 30 35
rich edges: 10 30
rich edges: 13 14
rich edges: 16 33
rich edges: 11 13 31 33

интересно, всегда ли будет оставаться 3 слоя по 2, 3 слоя по 4, или нет
нет, не всегда:

rich edges: 1 6 10 13 16 22 32 35
rich edges: 2 3 8 11 12 14 18 25 27 30 31 35
rich edges: 0 3 8 9 12 23 25 27 30 34
rich edges: 0 11 14 16 19 26 29 34
rich edges: 2 10 19 22 26 29 32 33
rich edges: 1 6 9 13 18 23 31 33

превращается в

rich edges: 13 16 32 35
rich edges: 2 35
rich edges: 
rich edges: 16 29
rich edges: 2 29 32 33
rich edges: 13 33

todo:
тогда такой вопрос - как ещё бывает? можно ли от всех избавиться?

20.05:
whats left: 2 2 2 2 2 2
22.05:
whats left: 0 0 2 2 2 2
whats left: 2 2 2 2 2 2
whats left: 4 4 4 4 4 4
22.04:
whats left: 0 0 2 2 2 2
whats left: 2 2 2 2 2 2
whats left: 2 2 4 4 4 4
whats left: 4 4 4 4 4 4
24.05:
whats left: 0 2 2 2 4 4
whats left: 2 2 2 2 2 2
whats left: 2 2 2 4 4 4
24.04:
whats left: 0 2 2 2 4 4
whats left: 2 2 2 2 2 2
whats left: 2 2 2 2 4 4
whats left: 2 2 2 4 4 4
whats left: 2 2 4 4 4 4
whats left: 4 4 4 4 4 4
26.05:
whats left: 0 0 2 2 2 2
whats left: 0 2 2 2 4 4
whats left: 2 2 2 2 2 2
whats left: 2 2 2 2 2 4
whats left: 2 2 2 4 4 4
whats left: 2 2 4 4 4 4
whats left: 4 4 4 4 4 4

пока что, как видно, невозможно избавиться попарно от всего

какие ещё числа можно придумать для 6c4c?
в голову приходила идея
посчитать пересечения между паросочетаниями
например
у графа петерсена паросочетания пересекаются по 1 ребру
типа нет слипшихся
давайте посчитаем в общем случае, сколько у нас слипаний
хотя я точно помню, что эта инфа не поможет с инвариантом
а ещё она сильно похожа на poor рёбра сама по себе


g26
new o6c4c: s0: 15; s1: 27; s2: 6; s3: 9;
Printing graph:
0:  12(e0)  4(e1) 8(e2)
1:  11(e3)  5(e4) 14(e5)
2:  7(e6) 4(e7) 9(e8)
3:  8(e9) 5(e10)  7(e11)
4:  0(e1) 2(e7) 5(e12)
5:  1(e4) 3(e10)  4(e12)
6:  15(e13) 13(e14) 7(e15)
7:  2(e6) 3(e11)  6(e15)
8:  0(e2) 3(e9) 9(e16)
9:  2(e8) 8(e16)  11(e17)
10: 12(e18) 15(e19) 18(e20)
11: 1(e3) 9(e17)  20(e21)
12: 0(e0) 10(e18) 13(e22)
13: 6(e14)  12(e22) 22(e23)
14: 1(e5) 19(e24) 15(e25)
15: 6(e13)  10(e19) 14(e25)
16: 18(e26) 20(e27) 17(e28)
17: 16(e28) 22(e29) 19(e30)
18: 10(e20) 16(e26) 21(e31)
19: 14(e24) 17(e30) 21(e32)
20: 11(e21) 16(e27) 23(e33)
21: 18(e31) 19(e32) 23(e34)
22: 13(e23) 17(e29) 23(e35)
23: 20(e33) 21(e34) 22(e35)
dominating cycle: 6(2,7) 7(2,4) 9(3,8) 10(3,5) 12(4,5) 14(6,13) 15(6,7) 16(8,9) 17(9,11) 18(10,12) 19(10,15) 21(11,20) 22(12,13) 24(14,19) 25(14,15) 26(16,18) 28(16,17) 29(17,22) 31(18,21) 32(19,21) 33(20,23) 35(22,23)
rich edges: 0(0, 12) 1(0, 4) 2(0, 8) 3(1, 11) 6(2, 7) 8(2, 9) 9(3, 8) 10(3, 5) 11(3, 7) 12(4, 5) 13(6, 15) 14(6, 13) 16(8, 9) 18(10, 12) 19(10, 15) 22(12, 13) 23(13, 22) 25(14, 15) 26(16, 18) 27(16, 20) 29(17, 22) 30(17, 19) 31(18, 21) 32(19, 21) 33(20, 23) 34(21, 23) 35(22, 23)
circuits:
layer: 0; vertices: 4 5 3 8 0 4
layer: 0; vertices: 11 1 14 15 6 7 2 9 11
layer: 0; vertices: 12 13 22 23 20 16 17 19 21 18 10 12
layer: 1; vertices: 12 0 4 2 7 6 15 10 18 16 17 22 13 12
layer: 1; vertices: 5 1 14 19 21 23 20 11 9 8 3 5
layer: 2; vertices: 12 13 6 7 3 5 4 2 9 8 0 12
layer: 2; vertices: 11 20 16 18 10 15 14 1 11
layer: 2; vertices: 22 23 21 19 17 22
layer: 3; vertices: 4 0 8 9 11 20 23 22 17 16 18 21 19 14 1 5 3 7 2 4
layer: 3; vertices: 15 6 13 12 10 15
layer: 4; vertices: 12 0 8 3 7 6 13 22 17 19 14 15 10 12
layer: 4; vertices: 11 9 2 4 5 1 11
layer: 4; vertices: 18 16 20 23 21 18
layer: 5; vertices: 12 10 18 21 23 22 13 6 15 14 19 17 16 20 11 1 5 4 0 12
layer: 5; vertices: 7 3 8 9 2 7


для o6c4c с 0 oriented вершин
могу ещё одну подклассификацию рёбер предложить
а именно
берём ребро из паросочетания
например,
ребро 0-12, циклы ->8->0->4-> и ->10->12->13->
в другом случае ориентация циклов будет противоположной
значит пары вершин (8, 10) и (4, 13) могут как-то друг другу соответствовать
	или наоборот, пары (8, 13) и (4, 10)
если 0-12 - rich ребро (выше так и есть), то
	2 раза это ребро будет в кусках (за ориентацию не ручаюсь)
		->8->0->12->10->
		->4->0->12->13->
	и другая пара:
		->8->0->12->13->
		->4->0->12->10->

вот
rich_same, rich_diff - 2 раза каждое
а вот poor_same, poor_diff - 4 раза одно, 0 раз другое
поэтому мы могли бы отдельно глянуть - сколько у нас poor_same, а сколько - poor_diff рёбер

24.05, t1+t3:
	0, 5, 6, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 30

boundary maps?
	по rich рёбрам, например
	а что, если от цепей надо переходить к паросочетаниям?
		а от них уже к вершинам, например
	если берём весь цикл, весь слой
		то должны получить более-менее всё паросочетание данного слоя, как вариант

может надо цепи по-другому немного посчитать?
типа
учесть число oriented вершин на цепях
	хотя это странно
	для t1+t3==0: всегда будет 0
	для t1+t3==3: такого не бывает, точняк
очень странно
-> та же самая чётность, что и просто у числа цепей в решении


так
предварительно гипотеза такая,
что когда мы в слое встречаем цикл с 3 oriented вершинами - надо менять чётность
но в общем ситуация сложнее
ещё придётся сделать твист, если 3 слоя, и oriented вершины там распределены - 0, 1, 2


хм, возможно так:
	0, 3 - надо
	1, 2 - не надо
	0, 1, 2 - надо
непонятно
попробую для начала просто посчитать цепи с 0 ориентированных вершин


значит
я умею управляться с 0 и 2 oriented вершинами


будущее:
s0 = число цепей
s1 = число rich рёбер
s2 = (число паросочетаний с чётным числом rich рёбер) / 2
	(= 0, 1, 2 или 3)
по модулю 2

есть 2 стратегии:
1) надо на самом деле просто подправить одно из этих чисел
	в ситуациях, когда oriented вершин больше 2
2) не хватает какого-то ещё одного слагаемого, кажется
	зависящего от вершин
	и это забавно, потому что
	я же знаю, что есть частично зависимость конфигурации rich рёбер от oriented вершин
	типа что, например,
	rich ребро не соединяет 2 oriented вершины


мб надо походу обе стратегии заюзать?
а именно
- надо добавить число oriented вершин
- надо подправить какое-то из определений с учётом того,
	что бывает 3 и больше oriented вершин
может вместо s1 надо брать t4?
	нет
	почему-то s1 и t4 разной чётности всегда на 3 вершинах
	вроде очевидно (потому что t3 == 9)
	да, действительно


new o6c4c: or: 3; t1+t3: 9; s0: 12; s1: 25; s2: 1; sum: -14; s0+s1+s2 parity: 0 (0)
new o6c4c: or: 3; t1+t3: 9; s0: 13; s1: 27; s2: 2; sum: -16; s0+s1+s2 parity: 0 (0)
new o6c4c: or: 3; t1+t3: 9; s0: 13; s1: 28; s2: 1; sum: -16; s0+s1+s2 parity: 0 (0)
new o6c4c: or: 3; t1+t3: 9; s0: 13; s1: 29; s2: 2; sum: -18; s0+s1+s2 parity: 0 (0)
new o6c4c: or: 3; t1+t3: 9; s0: 13; s1: 31; s2: 2; sum: -20; s0+s1+s2 parity: 0 (0)
new o6c4c: or: 3; t1+t3: 9; s0: 13; s1: 32; s2: 1; sum: -20; s0+s1+s2 parity: 0 (0)
new o6c4c: or: 3; t1+t3: 9; s0: 14; s1: 24; s2: 2; sum: -12; s0+s1+s2 parity: 0 (0)
new o6c4c: or: 3; t1+t3: 9; s0: 14; s1: 27; s2: 1; sum: -14; s0+s1+s2 parity: 0 (0)
new o6c4c: or: 3; t1+t3: 9; s0: 15; s1: 26; s2: 1; sum: -12; s0+s1+s2 parity: 0 (0)
new o6c4c: or: 3; t1+t3: 9; s0: 15; s1: 27; s2: 2; sum: -14; s0+s1+s2 parity: 0 (0)
new o6c4c: or: 3; t1+t3: 9; s0: 15; s1: 28; s2: 1; sum: -14; s0+s1+s2 parity: 0 (0)
new o6c4c: or: 3; t1+t3: 9; s0: 15; s1: 29; s2: 2; sum: -16; s0+s1+s2 parity: 0 (0)
new o6c4c: or: 3; t1+t3: 9; s0: 15; s1: 30; s2: 1; sum: -16; s0+s1+s2 parity: 0 (0)
new o6c4c: or: 3; t1+t3: 9; s0: 15; s1: 31; s2: 2; sum: -18; s0+s1+s2 parity: 0 (0)
new o6c4c: or: 3; t1+t3: 9; s0: 16; s1: 24; s2: 2; sum: -10; s0+s1+s2 parity: 0 (0)

s2 не 0
=> паросочетания может похитрее стали?


как интересно - на 24.05, там где 3 oriented вершины
	рядом с ними всегда по 3 rich ребра
	но это тоже очевидно
	(потому что t3==9)


new o6c4c: or: 3; t1+t3: 9; s0: 13; s1: 27; s2: 1; sum: -15; s0+s1+s2 parity: 1 (1) circ or freq: 3 4 4 2;
new o6c4c: or: 3; t1+t3: 9; s0: 13; s1: 27; s2: 2; sum: -16; s0+s1+s2 parity: 0 (0) circ or freq: 3 4 4 2;
вот тут явно что-то произошло с паросочетаниями
но что?




new o6c4c: or: 3; t1+t3: 9; s0: 13; s1: 27; s2: 2; sum: -16; s0+s1+s2 parity: 0 (0) circ or freq: 3 4 4 2;
dominating circuit: 2 11 10 12 13 17 16 8 9 22 18 19 7 6 20 23 21 3 5 4 14 15 2
rich edges: 0(0, 12) 1(0, 14) 2(0, 16) 3(1, 18) 4(1, 5) 5(1, 20) 6(2, 7) 8(2, 11) 9(3, 8) 10(3, 5) 12(4, 14) 13(4, 13) 14(4, 5) 17(6, 7) 19(8, 16) 20(8, 9) 21(9, 22) 22(9, 11) 23(10, 12) 24(10, 11) 25(12, 13) 27(14, 15) 28(15, 17) 29(16, 17) 31(18, 19) 33(20, 23) 35(22, 23)
poor edges: 7(2, 15) 11(3, 21) 15(6, 10) 16(6, 20) 18(7, 19) 26(13, 17) 30(18, 22) 32(19, 21) 34(21, 23)
oriented vertices: 1 8 11
circuits:
layer: 0; vertices: 14 4 5 1 18 19 21 3 8 16 0 14
layer: 0; vertices: 7 6 20 23 22 9 11 10 12 13 17 15 2 7
layer: 1; vertices: 14 0 16 17 15 14
layer: 1; vertices: 5 4 13 12 10 6 7 2 11 9 8 3 21 19 18 22 23 20 1 5
layer: 2; vertices: 12 0 16 8 9 22 23 21 3 5 4 14 15 17 13 12
layer: 2; vertices: 18 1 20 6 10 11 2 7 19 18
layer: 3; vertices: 12 0 14 15 2 11 9 22 18 1 20 23 21 19 7 6 10 12
layer: 3; vertices: 8 16 17 13 4 5 3 8
layer: 4; vertices: 12 13 4 14 0 12
layer: 4; vertices: 5 3 21 23 22 18 19 7 2 15 17 16 8 9 11 10 6 20 1 5
layer: 5; vertices: 12 10 11 2 15 14 4 13 17 16 0 12
layer: 5; vertices: 18 22 9 8 3 5 1 18
layer: 5; vertices: 20 6 7 19 21 23 20
matchings:
layer: 0; edges: 0(0, 12) 5(1, 20) 8(2, 11) 10(3, 5) 13(4, 13) 15(6, 10) 18(7, 19) 20(8, 9) 27(14, 15) 29(16, 17) 30(18, 22) 34(21, 23)
layer: 1; edges: 0(0, 12) 3(1, 18) 7(2, 15) 10(3, 5) 12(4, 14) 16(6, 20) 18(7, 19) 19(8, 16) 21(9, 22) 24(10, 11) 26(13, 17) 34(21, 23)
layer: 2; edges: 1(0, 14) 4(1, 5) 7(2, 15) 9(3, 8) 13(4, 13) 17(6, 7) 22(9, 11) 23(10, 12) 29(16, 17) 30(18, 22) 32(19, 21) 33(20, 23)
layer: 3; edges: 2(0, 16) 4(1, 5) 6(2, 7) 11(3, 21) 12(4, 14) 16(6, 20) 20(8, 9) 24(10, 11) 25(12, 13) 28(15, 17) 31(18, 19) 35(22, 23)
layer: 4; edges: 2(0, 16) 3(1, 18) 8(2, 11) 9(3, 8) 14(4, 5) 17(6, 7) 21(9, 22) 23(10, 12) 26(13, 17) 27(14, 15) 32(19, 21) 33(20, 23)
layer: 5; edges: 1(0, 14) 5(1, 20) 6(2, 7) 11(3, 21) 14(4, 5) 15(6, 10) 19(8, 16) 22(9, 11) 25(12, 13) 28(15, 17) 31(18, 19) 35(22, 23)
слои - 12, 03, 12, 12, 03, 012


new o6c4c: or: 3; t1+t3: 9; s0: 13; s1: 27; s2: 1; sum: -15; s0+s1+s2 parity: 1 (1) circ or freq: 3 4 4 2;
dominating circuit: 2 15 14 4 5 3 7 6 10 12 13 17 16 8 9 22 23 21 20 18 19 2
rich edges: 0(0, 12) 2(0, 16) 4(1, 5) 5(1, 20) 6(2, 7) 7(2, 15) 8(2, 19) 11(3, 7) 12(4, 14) 13(4, 13) 14(4, 5) 16(6, 18) 17(6, 7) 19(8, 21) 20(8, 9) 21(9, 22) 22(9, 11) 25(11, 19) 26(12, 13) 27(13, 17) 28(14, 15) 29(15, 17) 30(16, 17) 31(18, 20) 33(20, 21) 34(21, 23) 35(22, 23)
poor edges: 1(0, 14) 3(1, 22) 9(3, 23) 10(3, 5) 15(6, 10) 18(8, 16) 23(10, 12) 24(10, 11) 32(18, 19)
oriented vertices: 2 9 21
circuits:
layer: 0; vertices: 14 4 13 12 10 11 19 2 15 17 16 0 14
layer: 0; vertices: 5 1 20 18 6 7 3 5
layer: 0; vertices: 21 8 9 22 23 21
layer: 1; vertices: 12 0 16 17 13 12
layer: 1; vertices: 22 23 3 7 6 10 11 9 8 21 20 18 19 2 15 14 4 5 1 22
layer: 2; vertices: 12 13 4 5 3 23 21 8 16 17 15 14 0 12
layer: 2; vertices: 22 9 11 10 6 7 2 19 18 20 1 22
layer: 3; vertices: 12 0 14 15 2 7 3 23 22 9 11 19 18 6 10 12
layer: 3; vertices: 5 4 13 17 16 8 21 20 1 5
layer: 4; vertices: 14 0 16 8 9 22 1 20 21 23 3 5 4 14
layer: 4; vertices: 7 6 18 19 11 10 12 13 17 15 2 7
layer: 5; vertices: 12 10 6 18 20 21 23 22 1 5 3 7 2 19 11 9 8 16 0 12
layer: 5; vertices: 14 15 17 13 4 14
matchings:
layer: 0; edges: 0(0, 12) 3(1, 22) 6(2, 7) 9(3, 23) 14(4, 5) 15(6, 10) 18(8, 16) 22(9, 11) 27(13, 17) 28(14, 15) 32(18, 19) 33(20, 21)
layer: 1; edges: 1(0, 14) 5(1, 20) 6(2, 7) 10(3, 5) 13(4, 13) 16(6, 18) 18(8, 16) 21(9, 22) 23(10, 12) 25(11, 19) 29(15, 17) 34(21, 23)
layer: 2; edges: 2(0, 16) 4(1, 5) 7(2, 15) 11(3, 7) 12(4, 14) 16(6, 18) 20(8, 9) 23(10, 12) 25(11, 19) 27(13, 17) 33(20, 21) 35(22, 23)
layer: 3; edges: 2(0, 16) 3(1, 22) 8(2, 19) 10(3, 5) 12(4, 14) 17(6, 7) 20(8, 9) 24(10, 11) 26(12, 13) 29(15, 17) 31(18, 20) 34(21, 23)
layer: 4; edges: 0(0, 12) 4(1, 5) 8(2, 19) 11(3, 7) 13(4, 13) 15(6, 10) 19(8, 21) 22(9, 11) 28(14, 15) 30(16, 17) 31(18, 20) 35(22, 23)
layer: 5; edges: 1(0, 14) 5(1, 20) 7(2, 15) 9(3, 23) 14(4, 5) 17(6, 7) 19(8, 21) 21(9, 22) 24(10, 11) 26(12, 13) 30(16, 17) 32(18, 19)
слои - 012, 03, 12, 12, 12, 03

вообще как-то ненулёвость s2 решает тут большую роль, но как - не пойму

может быть надо соорудить 244-flows из решения?
да посчитать для него какой инвариант?

типа, вот этот 2-flow


посчитаю число связных компонент poor рёбер
посчитал, пока что ничего не дало

заодно выяснил, что одного только профиля мало, надо больше
более тонкий инвариант


а вот чётность числа ориентированных вершин скорее всего зависит только от профиля

or s0 s1
5 13 30
6 16 34
2 13 25
5 15 33
7 14 34
5 14 25
4 15 30
6 16 31
тут бывают все варианты


rv0, rv1, rv2, rv3:
	rv0+rv1+  rv2+  rv3 = 2*k
	    rv1+2*rv2+3*rv3 = 2*r
=>
rv0+rv2=0 (mod 2),
rv1+rv3=0 (mod 2)


rrrppprpprrrprrrrpprprrrrrrrrrppppprrrr
такой профиль возьму
0: ii
1: ii
и каких-нибудь 2 решения

26.05g24


число паросочетаний с чётным числом rich рёбер
=
6 - число полных циклов с чётным числом poor рёбер
попробую поменять в последнем
подсчёт poor
с учётом числа компонент связности
то есть буду просто считать компоненты
->	почему-то это число всегда чётно
	как так?


на самом деле проблема есть даже в 18.05g2
NEW 6C4C
prof: rrrrrrrrrrrrrrrprprrrrprrrr
new o6c4c: t1+t3: 9; or: 3; s0: 13; s1: 24; s2: 1; s': 2 3 6; sum parity: 0 (0);
NEW 6C4C
prof: rrrrprrrrrrrrrrprprrrrrrrrr
new o6c4c: t1+t3: 9; or: 3; s0: 13; s1: 24; s2: 1; s': 2 3 6; sum parity: 0 (0);
NEW 6C4C
prof: rrrrrrrrrrrrrprrrrrrrpprrrr
new o6c4c: t1+t3: 9; or: 3; s0: 13; s1: 24; s2: 1; s': 2 3 6; sum parity: 0 (0);
NEW 6C4C
prof: rrrrprrrrrrrrprrrrrrrprrrrr
new o6c4c: t1+t3: 9; or: 3; s0: 13; s1: 24; s2: 1; s': 2 3 6; sum parity: 0 (0);

пока не понял



TODO:
надо поизучать вот эти решения
s':
cerr << "s': " << odd_poor_full_cycles / 2 << " " <<
odd_poor_comps_full_cycles / 2 << " " <<
total_poor_comps << " " <<
poor_vertices.size() << " " <<
chords_frequency[1] << " " << chords_frequency[2] << "; ";

new o6c4c: or: 3; t1+t3: 9; s0: 13; s1: 23; s2: 1; s': 1 2 3 7 11 3; sum parity: 1 (1);
new o6c4c: or: 3; t1+t3: 9; s0: 13; s1: 24; s2: 1; s': 2 2 3 6 11 3; sum parity: 0 (0);
parity: 0 я уже нарисовал, надо теперь глянуть parity: 1 решение



prof: rrprprrrrrrrrprprrrrrrrrrrr
new o6c4c: or: 3; t1+t3: 9; s0: 13; s1: 23; s2: 1; s': 1 2 3 7 6 2; sum parity: 1 (1);
Printing graph:
0:  12(e0)  14(e1)  3(e2)
1:  9(e3) 5(e4) 6(e5)
2:  7(e6) 4(e7) 9(e8)
3:  0(e2) 5(e9) 7(e10)
4:  2(e7) 13(e11) 5(e12)
5:  1(e4) 3(e9) 4(e12)
6:  1(e5) 8(e13)  7(e14)
7:  2(e6) 3(e10)  6(e14)
8:  6(e13)  15(e15) 11(e16)
9:  1(e3) 2(e8) 11(e17)
10: 14(e18) 13(e19) 16(e20)
11: 8(e16)  9(e17)  16(e21)
12: 0(e0) 17(e22) 13(e23)
13: 4(e11)  10(e19) 12(e23)
14: 0(e1) 10(e18) 15(e24)
15: 8(e15)  14(e24) 17(e25)
16: 10(e20) 11(e21) 17(e26)
17: 12(e22) 15(e25) 16(e26)
dominating circuit: 1 5 3 7 2 9 11 16 17 12 13 10 14 15 8 6 1
rich edges: 0(0, 12) 1(0, 14) 3(1, 9) 5(1, 6) 6(2, 7) 7(2, 4) 8(2, 9) 9(3, 5) 10(3, 7) 11(4, 13) 12(4, 5) 14(6, 7) 16(8, 11) 17(9, 11) 18(10, 14) 19(10, 13) 20(10, 16) 21(11, 16) 22(12, 17) 23(12, 13) 24(14, 15) 25(15, 17) 26(16, 17)
poor edges: 2(0, 3) 4(1, 5) 13(6, 8) 15(8, 15)
oriented vertices: 13 14 16
circuits:
layer: 0; vertices: 14 10 16 11 9 2 7 3 0 14
layer: 0; vertices: 5 1 6 8 15 17 12 13 4 5
layer: 1; vertices: 12 17 15 14 0 12
layer: 1; vertices: 9 2 4 13 10 16 11 8 6 7 3 5 1 9
layer: 2; vertices: 12 0 14 10 13 12
layer: 2; vertices: 9 11 16 17 15 8 6 1 9
layer: 2; vertices: 7 2 4 5 3 7
layer: 3; vertices: 12 0 3 5 4 13 10 14 15 8 11 16 17 12
layer: 3; vertices: 9 1 6 7 2 9
layer: 4; vertices: 14 0 3 7 6 1 5 4 2 9 11 8 15 14
layer: 4; vertices: 13 12 17 16 10 13
layer: 5; vertices: 12 13 4 2 7 6 8 11 9 1 5 3 0 12
layer: 5; vertices: 14 15 17 16 10 14
matchings:
layer: 0; edges: 0(0, 12) 3(1, 9) 7(2, 4) 9(3, 5) 14(6, 7) 16(8, 11) 19(10, 13) 24(14, 15) 26(16, 17)
layer: 1; edges: 2(0, 3) 5(1, 6) 6(2, 7) 12(4, 5) 15(8, 15) 17(9, 11) 18(10, 14) 23(12, 13) 26(16, 17)
layer: 2; edges: 2(0, 3) 4(1, 5) 8(2, 9) 11(4, 13) 14(6, 7) 16(8, 11) 20(10, 16) 22(12, 17) 24(14, 15)
layer: 3; edges: 1(0, 14) 4(1, 5) 7(2, 4) 10(3, 7) 13(6, 8) 17(9, 11) 20(10, 16) 23(12, 13) 25(15, 17)
layer: 4; edges: 0(0, 12) 3(1, 9) 6(2, 7) 9(3, 5) 11(4, 13) 13(6, 8) 18(10, 14) 21(11, 16) 25(15, 17)
layer: 5; edges: 1(0, 14) 5(1, 6) 8(2, 9) 10(3, 7) 12(4, 5) 15(8, 15) 19(10, 13) 21(11, 16) 22(12, 17)



посчитать число (антихорд, хорд)
	которые соединяют цепи с учётом чётности числа rich рёбер в них

	а именно следующие 5 чисел:
	coo
	cee
	aoo
	aoe
	aee

	ничего не дало


s0 = число цепей
s1 = число rich рёбер
s2 = (число паросочетаний с чётным числом rich рёбер) / 2
	(= 0, 1, 2 или 3)
по модулю 2


26.05
new o6c4c: or: 03; t1+t3: 09; s0: 12; s1: 19; s2: 0; s': 0 3 3 18 0; PAR: 1 (1); SEAL; also pet!
new o6c4c: or: 03; t1+t3: 09; s0: 12; s1: 19; s2: 1; s': 1 0 2 16 0; PAR: 0 (0);

new o6c4c: or: 03; t1+t3: 09; s0: 16; s1: 23; s2: 0; s': 0 2 5 18 4; PAR: 1 (1); SEAL; also pet!
new o6c4c: or: 03; t1+t3: 09; s0: 16; s1: 23; s2: 1; s': 1 1 4 17 4; PAR: 0 (0);


new o6c4c: or: 05; t1+t3: 14; s0: 16; s1: 23; s2: 0; s': 0 2 5 18 2; PAR: 1 (1); SEAL; also pet!
new o6c4c: or: 05; t1+t3: 14; s0: 16; s1: 23; s2: 0; s': 0 2 5 19 2; PAR: 1 (1);
new o6c4c: or: 05; t1+t3: 14; s0: 16; s1: 23; s2: 0; s': 0 2 5 19 3; PAR: 1 (1);
new o6c4c: or: 05; t1+t3: 14; s0: 16; s1: 23; s2: 1; s': 1 1 4 17 2; PAR: 0 (0);
new o6c4c: or: 05; t1+t3: 14; s0: 16; s1: 23; s2: 1; s': 1 1 4 17 3; PAR: 0 (0);
new o6c4c: or: 05; t1+t3: 14; s0: 16; s1: 23; s2: 1; s': 1 2 3 15 3; PAR: 0 (0);


20.05
g1 new o6c4c: or: 05; t1+t3: 14; s0: 12; s1: 23; s2: 0; s': 0 1 4 11 0; PAR: 1 (1); SEAL; also pet!
g1 new o6c4c: or: 05; t1+t3: 14; s0: 12; s1: 23; s2: 0; s': 0 1 4 11 0; PAR: 1 (1);
g5 new o6c4c: or: 05; t1+t3: 14; s0: 12; s1: 23; s2: 1; s': 1 2 4 11 0; PAR: 0 (0);

вот идеально, надо глянуть
чёрт, тут разные графы немного

а вот чтоб графы совпали - не могу найти
	проверил до 24.05+22.04
в плане что
хочу найти граф, где при совпадающих s0 и s1
	у графа будут 2 решения - в одном есть petersen colouring, в другом - parity = 0

о
на 24.04 есть такой граф!
g120 18 21
g120 20 21
g133 18 21
g133 20 21


g120: new o6c4c: or: 03; t1+t3: 09; s0: 18; s1: 21; s2: 0; s': 0 1 4 16 6; PAR: 1 (1); SEAL;
g120: new o6c4c: or: 03; t1+t3: 09; s0: 18; s1: 21; s2: 0; s': 0 1 4 16 6; PAR: 1 (1); SEAL; also pet!
g120: new o6c4c: or: 03; t1+t3: 09; s0: 18; s1: 21; s2: 1; s': 1 2 3 14 6; PAR: 0 (0);

g120: new o6c4c: or: 03; t1+t3: 09; s0: 20; s1: 21; s2: 0; s': 0 1 4 16 8; PAR: 1 (1); SEAL;
g120: new o6c4c: or: 03; t1+t3: 09; s0: 20; s1: 21; s2: 0; s': 0 1 4 16 8; PAR: 1 (1); SEAL; also pet!
g120: new o6c4c: or: 03; t1+t3: 09; s0: 20; s1: 21; s2: 1; s': 1 2 3 14 8; PAR: 0 (0);

g133: new o6c4c: or: 07; t1+t3: 17; s0: 18; s1: 21; s2: 0; s': 0 1 4 16 2; PAR: 1 (1);
g133: new o6c4c: or: 07; t1+t3: 17; s0: 18; s1: 21; s2: 0; s': 0 1 4 16 2; PAR: 1 (1); SEAL; also pet!
g133: new o6c4c: or: 07; t1+t3: 17; s0: 18; s1: 21; s2: 1; s': 1 2 3 14 2; PAR: 0 (0);

g133: new o6c4c: or: 03; t1+t3: 09; s0: 20; s1: 21; s2: 0; s': 0 1 4 16 8; PAR: 1 (1); SEAL;
g133: new o6c4c: or: 03; t1+t3: 09; s0: 20; s1: 21; s2: 0; s': 0 1 4 16 8; PAR: 1 (1); SEAL; also pet!
g133: new o6c4c: or: 03; t1+t3: 09; s0: 20; s1: 21; s2: 1; s': 1 2 3 14 8; PAR: 0 (0);

и ещё пачка решений

вообще эти 2 графа как-то дико похожи

20 g120: new o6c4c: or: 03; t1+t3: 09; s0: 20; s1: 21; s2: 0; s': 0 1 4 16 8; PAR: 1 (1); SEAL; also pet!
72 g120: new o6c4c: or: 03; t1+t3: 09; s0: 20; s1: 21; s2: 1; s': 1 2 3 14 8; PAR: 0 (0);

20 g120: new o6c4c: or: 05; t1+t3: 14; s0: 20; s1: 21; s2: 0; s': 0 1 4 16 4; PAR: 1 (1); SEAL; also pet!
24 g120: new o6c4c: or: 05; t1+t3: 14; s0: 20; s1: 21; s2: 1; s': 1 2 3 14 2; PAR: 0 (0);
24 g120: new o6c4c: or: 05; t1+t3: 14; s0: 20; s1: 21; s2: 1; s': 1 2 3 14 4; PAR: 0 (0);
48 g120: new o6c4c: or: 05; t1+t3: 14; s0: 20; s1: 21; s2: 1; s': 1 2 3 14 6; PAR: 0 (0);


16 g133: new o6c4c: or: 03; t1+t3: 09; s0: 20; s1: 21; s2: 0; s': 0 1 4 16 8; PAR: 1 (1); SEAL; also pet!
48 g133: new o6c4c: or: 03; t1+t3: 09; s0: 20; s1: 21; s2: 1; s': 1 2 3 14 8; PAR: 0 (0);

16 g133: new o6c4c: or: 05; t1+t3: 14; s0: 20; s1: 21; s2: 0; s': 0 1 4 16 4; PAR: 1 (1); SEAL; also pet!
24 g133: new o6c4c: or: 05; t1+t3: 14; s0: 20; s1: 21; s2: 1; s': 1 2 3 14 4; PAR: 0 (0);
72 g133: new o6c4c: or: 05; t1+t3: 14; s0: 20; s1: 21; s2: 1; s': 1 2 3 14 6; PAR: 0 (0);



16 g133: new o6c4c: or: 05; t1+t3: 14; s0: 20; s1: 21; s2: 0; s': 0 1 4 16 4; PAR: 1 (1); SEAL; also pet!
24 g133: new o6c4c: or: 05; t1+t3: 14; s0: 20; s1: 21; s2: 1; s': 1 2 3 14 4; PAR: 0 (0);
гляну вот эти штуки

pet
oriented vertices: 17 19 20 22 23
oriented vertices: 12 14 19 22 23
oriented vertices: 16 18 20 22 23
oriented vertices: 12 16 21 22 23

par0
oriented vertices: 15 16 19 22 23
oriented vertices: 12 16 21 22 23
oriented vertices: 12 13 20 22 23



oriented vertices: 12 16 21 22 23
воо, беру



s1 - число rich рёбер
e=27, 18.05: 17,20,22-24
e=30, 20.05: 17-29
e=33, 22.05: 17-31,33
e=36, 24.05: 17-35
e=39, 26.05: 17-39
e=42, 28.05: 17-41
то есть бывают o6c4c решения и с 1 poor ребром, и с 0 poor рёбер


кстати, бывает dominating circuit: FAIL
	значит условие на чётность poor рёбер - вероятно неправильное



todo:
	тут всплыло очень интересное наблюдение:
	меньше 15 rich рёбер не бывает
	а также не бывает 16 rich рёбер
	somehow это очень похоже на petersen colouring, но им не является
	а что это тогда?

как интересно
o6c4c, s1=17
18.05: всё ок
20.05: всё ок
22.05: всё ок
24.05: всё ок, а ещё они все petersen
26.05: всё ок
28.05: всё ок (petersen'овость не проверял, слишком долго будет)

old_parity = 0, s1:
 18.05: 24
 20.05: 23-27
 22.04: 21-31
 24.05: 22-34
(24.04: 21-34)
 26.04: 19-37
 28.05: 19-41


6c4c
s1 - число rich рёбер
e=27, 18.05: 17,19,20,22-24
e=30, 20.04: 17-29
e=33, 22.04: 17-33
e=36, 24.04: 17-35
e=39, 26.05: 17-39
e=42, 28.05: 17-41

old_parity = 0, s1:
 18.05: 19,20,24
 20.05: 17,19-28
 22.04: 17,19-31
 24.05: 17,19-34
(24.04: 17,19-35)
 26.05: 17,19-38
 28.05: 17,19-41

s0, # vs old_parity=0:
 18.05: 12,13 vs 13
 20.05: 12-16 vs 12-15
 22.05: 12-18 vs 12-17
(22.04: 12-18 vs 12-18)
 24.05: 12-18,20 vs 12-17
(24.04: 12-20 vs 12-20)
 26.05: 12-22 vs 12-22
 28.05: 12-24 vs 12-23



->	я нашёл частично источник расхождения в parity:
		odd_poor_full_cycles > 0
		по-крайней мере до 22.05 включительно
		на 24.05 надо исправлять уже кейсы s2=0, odd_poor_full_cycles=0
		на 26.05 уже s2=3

	а может дело в circuits_odd_poor?
		до 24.05 это похоже на правду
		на 26.05 это неправда (5 случаев, где circuits_odd_poor=0, parity=0)


на самом деле мысль такая
беру цепи
иду по ним
и смотрю на длины компонент poor рёбер
иду по rich ребру - прибавляю 1
дальше если компонента poor рёбер - смотрю сколько их
если их нечётно - меняю знак - теперь, когда иду по rich ребру - вычитаю 1
если длина poor компоненты была чётной - ничего не меняю
в итоге, если решение петерсенового
	то в каждом слое будет 2 цепи длины 5
	а остальные длины 0
	и никогда не будет противоречий, что мы вернулись в исходную точку, а у нас знак поменялся
	(то есть на каждой цепи чётное число нечётных poor компонент)
	не, как выясняется - это неправда, ситуация сложнее
а что в общем случае?
это вопрос
и влияют ли oriented вершины как-нибудь?




g133: new o6c4c: or: 05; t1+t3: 14; s0: 20; s1: 21; s2: 0; s': 0 1 4 16 4; PAR: 1 (1); SEAL; also pet!
Printing graph:
0:  22(e0)  4(e1) 8(e2)
1:  11(e3)  5(e4) 16(e5)
2:  7(e6) 4(e7) 9(e8)
3:  8(e9) 5(e10)  7(e11)
4:  0(e1) 2(e7) 5(e12)
5:  1(e4) 3(e10)  4(e12)
6:  10(e13) 12(e14) 23(e15)
7:  2(e6) 3(e11)  23(e16)
8:  0(e2) 3(e9) 9(e17)
9:  2(e8) 8(e17)  11(e18)
10: 6(e13)  22(e19) 15(e20)
11: 1(e3) 9(e18)  13(e21)
12: 6(e14)  18(e22) 17(e23)
13: 11(e21) 15(e24) 19(e25)
14: 16(e26) 18(e27) 20(e28)
15: 10(e20) 13(e24) 20(e29)
16: 1(e5) 14(e26) 17(e30)
17: 12(e23) 16(e30) 21(e31)
18: 12(e22) 14(e27) 19(e32)
19: 13(e25) 18(e32) 21(e33)
20: 14(e28) 15(e29) 21(e34)
21: 17(e31) 19(e33) 20(e34)
22: 0(e0) 10(e19) 23(e35)
23: 6(e15)  7(e16)  22(e35)
dominating circuit: 1 5 4 2 9 8 3 7 23 22 10 15 13 19 21 17 12 18 14 16 1
rich edges: 0(0, 22) 4(1, 5) 5(1, 16) 14(6, 12) 15(6, 23) 16(7, 23) 18(9, 11) 19(10, 22) 22(12, 18) 23(12, 17) 24(13, 15) 25(13, 19) 26(14, 16) 27(14, 18) 28(14, 20) 29(15, 20) 30(16, 17) 31(17, 21) 32(18, 19) 33(19, 21) 34(20, 21)
poor edges: 1(0, 4) 2(0, 8) 3(1, 11) 6(2, 7) 7(2, 4) 8(2, 9) 9(3, 8) 10(3, 5) 11(3, 7) 12(4, 5) 13(6, 10) 17(8, 9) 20(10, 15) 21(11, 13) 35(22, 23)
oriented vertices: 12 16 21 22 23
circuits:
layer: 0; vertices: 4 5 3 7 2 9 8 0 4
layer: 0; vertices: 11 13 15 10 22 23 6 12 17 16 1 11
layer: 0; vertices: 18 14 20 21 19 18
layer: 1; vertices: 4 0 8 9 2 7 3 5 4
layer: 1; vertices: 11 1 16 14 20 15 13 11
layer: 1; vertices: 10 22 23 6 10
layer: 1; vertices: 18 19 21 17 12 18
layer: 2; vertices: 22 10 15 13 19 18 12 6 23 7 2 4 0 22
layer: 2; vertices: 11 1 5 3 8 9 11
layer: 2; vertices: 16 17 21 20 14 16
layer: 3; vertices: 22 0 4 2 7 23 22
layer: 3; vertices: 5 1 16 14 18 19 13 11 9 8 3 5
layer: 3; vertices: 10 6 12 17 21 20 15 10
layer: 4; vertices: 22 0 8 3 7 23 22
layer: 4; vertices: 5 4 2 9 11 13 19 21 17 16 1 5
layer: 4; vertices: 10 15 20 14 18 12 6 10
layer: 5; vertices: 22 10 6 23 7 3 8 0 22
layer: 5; vertices: 11 9 2 4 5 1 11
layer: 5; vertices: 18 14 16 17 12 18
layer: 5; vertices: 15 20 21 19 13 15
matchings:
layer: 0; edges: 0(0, 22) 4(1, 5) 7(2, 4) 9(3, 8) 13(6, 10) 16(7, 23) 18(9, 11) 22(12, 18) 25(13, 19) 26(14, 16) 29(15, 20) 31(17, 21)
layer: 1; edges: 0(0, 22) 4(1, 5) 7(2, 4) 9(3, 8) 14(6, 12) 16(7, 23) 18(9, 11) 20(10, 15) 25(13, 19) 27(14, 18) 30(16, 17) 34(20, 21)
layer: 2; edges: 2(0, 8) 5(1, 16) 8(2, 9) 11(3, 7) 12(4, 5) 13(6, 10) 21(11, 13) 23(12, 17) 27(14, 18) 29(15, 20) 33(19, 21) 35(22, 23)
layer: 3; edges: 2(0, 8) 3(1, 11) 8(2, 9) 11(3, 7) 12(4, 5) 15(6, 23) 19(10, 22) 22(12, 18) 24(13, 15) 28(14, 20) 30(16, 17) 33(19, 21)
layer: 4; edges: 1(0, 4) 3(1, 11) 6(2, 7) 10(3, 5) 15(6, 23) 17(8, 9) 19(10, 22) 23(12, 17) 24(13, 15) 26(14, 16) 32(18, 19) 34(20, 21)
layer: 5; edges: 1(0, 4) 5(1, 16) 6(2, 7) 10(3, 5) 14(6, 12) 17(8, 9) 20(10, 15) 21(11, 13) 28(14, 20) 31(17, 21) 32(18, 19) 35(22, 23)


vs


g133: new o6c4c: or: 05; t1+t3: 14; s0: 20; s1: 21; s2: 1; s': 1 2 3 14 4; PAR: 0 (0);
Printing graph:
0:  22(e0)  4(e1) 8(e2)
1:  11(e3)  5(e4) 16(e5)
2:  7(e6) 4(e7) 9(e8)
3:  8(e9) 5(e10)  7(e11)
4:  0(e1) 2(e7) 5(e12)
5:  1(e4) 3(e10)  4(e12)
6:  10(e13) 12(e14) 23(e15)
7:  2(e6) 3(e11)  23(e16)
8:  0(e2) 3(e9) 9(e17)
9:  2(e8) 8(e17)  11(e18)
10: 6(e13)  22(e19) 15(e20)
11: 1(e3) 9(e18)  13(e21)
12: 6(e14)  18(e22) 17(e23)
13: 11(e21) 15(e24) 19(e25)
14: 16(e26) 18(e27) 20(e28)
15: 10(e20) 13(e24) 20(e29)
16: 1(e5) 14(e26) 17(e30)
17: 12(e23) 16(e30) 21(e31)
18: 12(e22) 14(e27) 19(e32)
19: 13(e25) 18(e32) 21(e33)
20: 14(e28) 15(e29) 21(e34)
21: 17(e31) 19(e33) 20(e34)
22: 0(e0) 10(e19) 23(e35)
23: 6(e15)  7(e16)  22(e35)
dominating circuit: 1 5 4 2 9 8 3 7 23 22 10 15 13 19 21 17 12 18 14 16 1
rich edges: 0(0, 22) 5(1, 16) 14(6, 12) 15(6, 23) 16(7, 23) 19(10, 22) 20(10, 15) 21(11, 13) 22(12, 18) 23(12, 17) 24(13, 15) 25(13, 19) 26(14, 16) 27(14, 18) 28(14, 20) 29(15, 20) 30(16, 17) 31(17, 21) 32(18, 19) 33(19, 21) 34(20, 21)
poor edges: 1(0, 4) 2(0, 8) 3(1, 11) 4(1, 5) 6(2, 7) 7(2, 4) 8(2, 9) 9(3, 8) 10(3, 5) 11(3, 7) 12(4, 5) 13(6, 10) 17(8, 9) 18(9, 11) 35(22, 23)
oriented vertices: 12 16 21 22 23
circuits:
layer: 0; vertices: 4 5 3 7 2 9 8 0 4
layer: 0; vertices: 11 13 15 20 14 16 1 11
layer: 0; vertices: 10 22 23 6 10
layer: 0; vertices: 18 12 17 21 19 18


layer: 1; vertices: 22 10 15 13 11 9 8 3 5 1 16 17 12 6 23 7 2 4 0 22
layer: 1; vertices: 18 19 21 20 14 18

layer: 2; vertices: 4 0 8 9 2 7 3 5 4
layer: 2; vertices: 11 1 16 17 21 19 13 11
layer: 2; vertices: 12 18 14 20 15 10 22 23 6 12

layer: 3; vertices: 22 0 8 3 7 23 22
layer: 3; vertices: 11 9 2 4 5 1 11
layer: 3; vertices: 10 6 12 18 19 13 15 10
layer: 3; vertices: 16 14 20 21 17 16


layer: 4; vertices: 22 0 4 2 7 23 22
layer: 4; vertices: 5 3 8 9 11 13 19 18 14 16 1 5
layer: 4; vertices: 10 15 20 21 17 12 6 10
layer: 5; vertices: 22 10 6 23 7 3 8 0 22
layer: 5; vertices: 11 1 5 4 2 9 11
layer: 5; vertices: 18 12 17 16 14 18
layer: 5; vertices: 15 13 19 21 20 15
matchings:
layer: 0; edges: 0(0, 22) 4(1, 5) 7(2, 4) 9(3, 8) 14(6, 12) 16(7, 23) 18(9, 11) 20(10, 15) 25(13, 19) 27(14, 18) 30(16, 17) 34(20, 21)
layer: 1; edges: 2(0, 8) 3(1, 11) 8(2, 9) 11(3, 7) 12(4, 5) 13(6, 10) 22(12, 18) 25(13, 19) 26(14, 16) 29(15, 20) 31(17, 21) 35(22, 23)
layer: 2; edges: 0(0, 22) 4(1, 5) 7(2, 4) 9(3, 8) 13(6, 10) 16(7, 23) 18(9, 11) 23(12, 17) 24(13, 15) 26(14, 16) 32(18, 19) 34(20, 21)
layer: 3; edges: 1(0, 4) 5(1, 16) 6(2, 7) 10(3, 5) 15(6, 23) 17(8, 9) 19(10, 22) 21(11, 13) 23(12, 17) 27(14, 18) 29(15, 20) 33(19, 21)
layer: 4; edges: 2(0, 8) 3(1, 11) 8(2, 9) 11(3, 7) 12(4, 5) 15(6, 23) 19(10, 22) 22(12, 18) 24(13, 15) 28(14, 20) 30(16, 17) 33(19, 21)
layer: 5; edges: 1(0, 4) 5(1, 16) 6(2, 7) 10(3, 5) 14(6, 12) 17(8, 9) 20(10, 15) 21(11, 13) 28(14, 20) 31(17, 21) 32(18, 19) 35(22, 23)
перелейблю
0 -> 1
1 -> 0
2 -> 4
3 -> 2
4 -> 3
5 -> 5



как сокращать poor рёбра
беру 6c4c
беру poor ребро
смотрю - кого оно соединяет
дальше формирую новый граф и новое 6c4c решение сразу
и по новой - смотрю какие poor рёбра в нём и сокращаю одно из них
при этом в теории я могу сохранить номера вершин
	что я понимаю про эту операцию:
		- число цепей только уменьшается
		- если в одном слое получилась 1 цепь - то мы явно вышли из мира снарков,
			и тут уже непонятно вот что - мого ли я дойти до того, что все рёбра станут poor?
		- мне кажется, что сохраняется наличие dominating circuit'а при такой операцииx




8 12 13 10 7 15 14 5 8
8 12 13 5 14 10 7 15 8
8 15 7 12 13 10 14 5 8
8 15 14 10 7 12 13 5 8
8 12 7 10 13 5 14 15 8
8 12 7 15 14 10 13 5 8
e: 8, 12
e: 8, 15
e: 10, 14
e: 10, 13
e: 12, 13
e: 14, 15
e: 5, 14
e: 7, 12
e: 5, 8
e: 7, 10
e: 5, 13
e: 7, 15


6 15 14 4 8 12 13 10 6
4 13 12 8 15 6 10 14 4
6 15 8 4 14 10 13 12 6
4 13 12 6 10 14 15 8 4
4 13 10 6 12 8 15 14 4
4 13 10 14 15 6 12 8 4
e: 4, 13
e: 6, 15
e: 8, 12
e: 8, 15
e: 10, 14
e: 10, 13
e: 12, 13
e: 14, 15
e: 4, 8
e: 6, 10
e: 4, 14
e: 6, 12

ну вот
2 разных подграфа
хм, и они не петерсеновы
ну да, оба с 6 гамильтоновыми циклами
прикольно


оп-па
нашёлся граф, где все рёбра rich
и в нём нечётное число цепей
это не снарк, да
кажется на неснарках вообще вся теория ломается



g147: another 6c4c: profile: rpppppppppppprprrrppprrrrrrrrrrrrrrr; s1= 20; comps: 1 1; or: 4;
g147: another 6c4c: profile: rrrrrrrrrrrrrrrrrrrrrrrrrprpprrrrrrp; s1= 32; comps: 1 1; or: 9;

g66: another 6c4c: profile: prrrrprrrrrrrrrpprrrrppprrppppprrrrr; s1= 24; comps: 1 1; or: 6;
g66: another 6c4c: profile: prrrrrrrrrrrrrrpprrrrppprrpppppprrrr; s1= 24; comps: 1 1; or: 6;
g66: another 6c4c: profile: prrrrrrrrrrrrrrpprrrrppprrppppprrrrr; s1= 25; comps: 1 1; or: 6;
g66: another 6c4c: profile: rrrrrprrrrrrrrrppprrrppprrppppprrrrr; s1= 24; comps: 1 1; or: 6;
g66: another 6c4c: profile: rrrrrrrrrrrrrrrppprrrppprrpppppprrrr; s1= 24; comps: 1 1; or: 6;
g66: another 6c4c: profile: rrrrrrrrrrrrrrrppprrrppprrppppprrrrr; s1= 25; comps: 1 1; or: 6;
g66: another 6c4c: profile: rrrppprrrrrrrrrpprrrrppppppppppprppp; s1= 17; comps: 1 1; or: 3;

g70: another 6c4c: profile: rpppprpppppppprrrppprrrrrrrrrrrprrrr; s1= 20; comps: 1 1; or: 4;
g70: another 6c4c: profile: rrrprprrrrrrrrpprrrrppppppppppprpppp; s1= 17; comps: 1 1; or: 3;

g101: another 6c4c: profile: rrrppprrrrrrrrrrrrrrrrprrrrrrrrrrrrp; s1= 31; comps: 1 1; or: 5;
g101: another 6c4c: profile: rrrrrrrrrrrrrrpprrrpprrppppppppppppr; s1= 20; comps: 1 1; or: 4;

g136: another 6c4c: profile: rpppprpppppppprrrppprrrrrrrrrrrrrrpr; s1= 20; comps: 1 1; or: 4;
g136: another 6c4c: profile: rrrprprrrrrrrrpprrrrpppppppppppppprp; s1= 17; comps: 1 1; or: 3;


наблюдения:
or = 0, poor_comps > 3
	20.05, 22.04, 24.04, 26.05
	poor_comps > 2:
	26.04

or = 2, poor_comps > 1
 	20.05, 22.04, 24.04, 26.04

только здесь надо быть аккуратнее - я выписываю только первый попавшийся or, для скорости
и для чётности
поэтому надо скептичнее отнестись к этим числам выше



на 26.05 есть 2 кейса, где 1 poor ребро, 38 rich рёбер
в одном случае 6 oriented, в другом 7
но это в целом по всем 26.05
а вот на 26.04 есть такое же в пределах одного графа


g1026: another 6c4c: profile: rrrrrrrrrrrrrrrrrrrrrrrrrrrrprrrrrrrrrr; s1= 38; comps: 1 1; or: 5;
g1026: another 6c4c: profile: rrrrrrrrrrrrrrrrrrrrrrrrrrrrprrrrrrrrrr; s1= 38; comps: 1 1; or: 7;
g1026: another 6c4c: profile: rrrrrprrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr; s1= 38; comps: 1 1;
g1026: another 6c4c: profile: rrrrrrrrrrrrrrrprrrrrrrrrrrrrrrrrrrrrrr; s1= 38; comps: 1 1;
g1026: another 6c4c: profile: rrrrrrrrrrrrrrrprrrrrrrrrrrrrrrrrrrrrrr; s1= 38; comps: 1 1; or: 8;
g1026: another 6c4c: profile: rrrrprrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr; s1= 38; comps: 1 1;




беру направленную цепь
и смотрю куда смотрят рёбра
и вычисляю тройки - полож. или отриц.
может ли быть так
что те 2 инварианта что я ищу - оба проистекают из chord diagrams?
хотя нет - первый в себя включает rich/poor,
второй наоборот вообще не учитывает цепей


во
не знаю как, но надо проверить вот такую идею
смотрю на профили rich-poor
беру эквивалентность теперь ещё и а-ля signed graphs - могу в вершине поменять все rich на poor и наоборот
и хочется понять
	много ли профилей я смогу объединить
	сохранится ли единая чётность для числа oriented вершин
Two signed graphs S1 and S2 with the same underlying graph are switching equivalent if, and only if, they are cycle isomorphic.
можно начать вот с этого определения


ой
я заврался
oriented_vertices % 2 зависит от 6c4c решения, а не от профиля
ну тогда увы
хотя зависимость будет очень тонкая, или она сломается ещё дальше
первый контрпример на 28.05g2869



u   total_poor_comps
ob  poor_breaking_orientation
u   poor_antichords
u   odd_poor_full_cycles
u   circuits_odd_poor
u   circuits_one_poor
u   odd_poor_comps_full_cycles
u   vertices_neib_to_poor_edge
ob  circuits_without_oriented_vertices
ob  (poor_breaking_orientation + circuits_without_oriented_vertices)

ob  rich_unoriented_vertices_frequency[0]
ob  rich_unoriented_vertices_frequency[2]
o   (rich_unoriented_vertices_frequency[0] + rich_unoriented_vertices_frequency[2])


можно ещё напридумать терминов, которые зависят от oriented вершин:
	chords vs oriented vertices
b  coo
b  cou
b  cuu
b  aoo
b  aou
b  auu


число паросочетаний с чётным числом oo, ou, uu рёбрами
b  oo
!  ou (0 или 3)
b  uu
!  (oo+uu) % 2



circuits: odd/even poor, odd/even oriented
opoo, opeo, epoo, epeo
такое ощущение, что тут инвариантны чётности любой суммы (или разности) двух чисел отсюда
а с другой стороны
opoo + epoo посчитает число odd oriented цепей, это число всегда чётно
и т. д.


может глянуть 6c4c, где много разных oriented?
например, 24.05g2:
g2: new o6c4c: or: 03; t1+t3: 09; s0: 14; s1: 29; s2: 2; t3: 9; t4: 20; PAR: 1 (1);
g2: new o6c4c: or: 05; t1+t3: 15; s0: 14; s1: 29; s2: 2; t3: 15; t4: 14; PAR: 1 (1);
g2: new o6c4c: or: 07; t1+t3: 21; s0: 14; s1: 29; s2: 2; t3: 21; t4: 8; PAR: 1 (1);
g2: new o6c4c: or: 09; t1+t3: 24; s0: 14; s1: 29; s2: 2; t3: 21; t4: 8; PAR: 1 (1);

26.05
ors: 0 6 8
ors: 2 4 12
ors: 2 6 10
ors: 2 6 12
ors: 2 8 10
ors: 3 7 11


а может док-во для совпадения чётности числа or вершин такое?
	типа
	берём любое o6c4c
	теперь смотрим другое
	и пытаемся глянуть дифф
	и дифф всегда чётный
	вот

	что такое дифф, осталось понять
	дифф у нас по направлениям по цепям
	какие-то из цепей поменяли направления


	если вершина поменяла тип (например, oriented -> unoriented)
		то в ней произошло нечётное число смен ориентации

	2 0 2 0 2 0
	0 2 0 2 0 2
	1 1 1 1 1 1
	одна смена ориентации это (2 0) <-> (1 1)
	если просуммировать по всем вершинам, то
	по идее получим чётную смену
	почему?
		потому что в каждом ребре чётное число рёбер меняет ориентацию

	пока что это похоже на правду.


как посчитать чётность числа oriented вершин, используя только числа из неориентированного решения?
мне кажется надо заюзать chords и antichords
но как


3
7 7 1 7 7 3

============

4
7 3 1 1 3 7

6
7 3 4 3 4 3

8
7 5 7 7 5 3







3
4 1 1 6 2 0

============

4
6 2 1 0 2 5

6
4 0 0 0 0 0

8
0 1 2 3 0 0


ну зато
значит
классифицируем хорды по частоте
0,1,2
и посчитаем, сколько у нас в каждом слое хорд частоты 1
и посмотрим на кейсы 0 0 0 0 0 0
тогда кажется, что чётность or зависит от графа
на 24.05: g5, g19 - для них чётно, для остальных нечётно

а если хорды частоты 2 и кейсы 0 0 0 0 0 0
везде нечётно

22.04:
ch1l: g4, g13, g23
ch2l: всё нечётно

24.04:
ch1l:
ch2l: g109 (чётный or)


g15, g32, g51, g61, g127, g128, g140


done:
проверить, что внутри каждого графа
если есть совпадения в профилях ch0l, ch1l, ch1chl, ch2l,
то чётности or одни и те же

ch0l сломал
ch1l сломал
ch1chl сломал
ch2l сломал

24.05
g8: new o6c4c: or: 05; t1+t3: 14; s0: 14; s1: 30; s2: 3; t3: 13; t4: 17; ch0l: 4 5 5 6 6 6 ; ch1l: 4 5 5 6 6 6 ; ch1chl: 0 2 2 2 5 5 ; ch2l: 0 0 1 2 2 3 ; PAR: 1 (1);
g8: new o6c4c: or: 07; t1+t3: 20; s0: 14; s1: 29; s2: 1; t3: 19; t4: 10; ch0l: 4 5 5 6 6 6 ; ch1l: 4 5 5 6 6 6 ; ch1chl: 0 2 2 2 5 5 ; ch2l: 0 0 1 2 2 3 ; PAR: 0 (0);
g8: new o6c4c: or: 06; t1+t3: 17; s0: 14; s1: 29; s2: 1; t3: 16; t4: 13; ch0l: 4 5 5 6 6 6 ; ch1l: 4 5 5 6 6 6 ; ch1chl: 0 2 2 2 5 5 ; ch2l: 0 0 1 2 2 3 ; PAR: 0 (0);
сильно, однако



окей
перехожу к другой теме
к o6c4c vs 2bm

наверно правильный контекст:
	o6c4c vs 33pp, пересекаю по nz-mod5
	и проверяю, что:
		- oriented лежат на цикле 33pp
		- веса равны одному из двух вариантов:
		(-1, -1, 0, 0, 1, 1)
		(-2, -1, 0, 0, 1, 2)
	- отдельно хочется проверить, что множество решений o6c4c, из которых можно получить nz5
	и множество o6c4c решений, из которых можно получить nz-mod5 - одно и то же
	(а может нет)
	- и отдельно хочется пересечь по nz-mod6 и посмотреть что будет там происходить






yeeee! taken
0: 4 5 3 7 2 9 8 0 4
1: 11 13 15 10 22 23 6 12 17 16 1 11
6: 18 19 21 17 12 18
8: 11 9 8 3 5 1 11
9: 16 17 21 20 14 16
11: 5 4 2 9 11 13 19 18 14 16 1 5
13: 22 23 7 2 4 0 22
15: 10 15 20 14 18 12 6 10
16: 22 10 6 23 7 3 8 0 22
19: 15 20 21 19 13 15



так
	26.05
	s2 = 0 или 3
	s0 чётно
	2cds: 0
	parity = 1
что я могу из этого коктейля вытащить:
	or и  s1 всё ещё могут быть разной чётности
	зато odd_poor_full_cycles == 0
	интересно

если s2 = 0 или 3
то odd_poor_full_cycles == 0 или 3
если odd_poor_full_cycles == 3, то что это за случаи:
	2 cdcs: 0 (логично)
	s0 совпадает по чётности с parity
	а это значит, что
	s1 и s2 совпадают по чётности

формула s0+s1+s2 трещит по швам
не, не трещит, просто я слишком одинаковые числа изучаю
не надо так


odd_poor_full_cycles: число слоёв с нечётным числом poor рёбер / 2
s2: even_rich_matchings / 2
s1 = total_rich_count
кажется эти числа будут связаны с числом рёбер в графе и с s1 слишком явно


26 вершин - 26 рёбер в full cycle и 13 рёбер в matching
odd_poor_full_cycles == 3:
r = 0, p = 1 => s1 = 0, 
r = 1, p = 0 => s1 = 1


всё что надо, только 2 cdcs нету
g1: new o6c4c: or: 07; t1+t3: 18; s0: 12; s1: 27; s2: 0; t3: 15; t4: 12; PAR: 1 (1); s': 0; has 2cdcs: 0;

может ли or быть чётным, а всё остальное таким же?
	нет


далее
s' = odd_poor_full_cycles
не получается
если я беру s'=0, чётный or, и смотрю на нечётный s1, то сразу получаю:
	s2 = 0
	s0 противоположен по чётности с parity
	t3 чётный
	t4 нечётный

я это к тому, что походу есть формула на
	без s0 (обидно) и наверно без s2
	но использует or, s1 и s'
например
or+s1+s'


лол, блин, если я хочу формулу на or, то
надо выкидывать t3, как следствие t4 тоже


s'=1:
чётный or, и смотрю на нечётный s1:
	s0 совпадает с parity по чётности


так
я забиваю на s' или на s2


точнее так:
	(s1+s2+odd_poor_full_cycles) % 2 == 1
	и это тривиальная штука

но
когда odd_poor_full_cycles == 0
у нас очень мало кейсов где par = 0
	равносильно тому, что s0 нечётно в этих кейсах
на 28.05,
s'=0: 380326 решений
parity = 0: 1398 решений


наверно формула плохая
про s0+s1+s2
если брать 2 cdc,
или petersen 6c4c,
то там чётность s0, чётность odd_poor_full_cycles и s1+s2+odd_poor_full_cycles == 1 влияют
то есть совпадение чётностей s0 и odd_poor_full_cycles


я бы хотел такую формулу:
	or + s0 + odd_poor_full_cycles
	(такая формула не работает при or == 0, or == 2
	мб правда я хочу получить 0 - тогда работает)

	26.05
	76609
	было - 63179
	стало - 57336

	28.05
	1385600
	было - 1092963
	стало - 985669


интересно,
что в неориентированных кейсах
бывает нечётный s0 и при этом есть 2 cdcs
	odd_poor_full_cycles == 0 всё ещё




s1 + s2 + odd_poor_full_cycles
or == 0
total -> comps
s1 -> total_rich_comps
s2 -> число паросочетаний с чётным числом rich-компонент рёбер
	s2 -> even_rich_comps_matchings
	на 24.05 - 0,1,2,4,5,6 (1 и 5 - по 1 примеру на каждый)
	на 2 не делится
odd_poor_full_cycles -> odd_poor_comps_full_cycles
облом





ребро 14-0 накрыто 4 раза
layer: 0; vertices: 14-15 8 11 9 1 6 7 2 4 5 3 0 14 ; rich-poor len: -1
layer: 1; vertices: 14 10 16 11 9 2 7 3 0 14 ; rich-poor len: -1
layer: 2; vertices: 12 13 4 5 1 6 8 11 9 2 7 3 0 12 ; rich-poor len: -1
layer: 3; vertices: 12 17 15-14 0 12 ; rich-poor len: 5
layer: 4; vertices: 12 13 10 14 0 12 ; rich-poor len: 5
layer: 5; vertices: 12 17 16 11 9 1 5 3 0 12 ; rich-poor len: -1


layer 0: +13 -5
layer 1: +9 -9
layer 2: +13 -5
layer 3: +5 -13
layer 4: +5 -8 -5
layer 5: +9 -9


layer: 0; vertices: 13 12 17 16 10 13 ; rich-poor len: 5
layer: 1; vertices: 5 4 13 12 17 15 8 6 1 5 ; rich-poor len: 5
layer: 2; vertices: 14-15 17 16 10 14 ; rich-poor len: 5
layer: 3; vertices: 9 2 4 13 10 16 11 8 6 7 3 5 1 9 ; rich-poor len: 5
layer: 4; vertices: 9 2 4 5 3 7 6 1 9 ; rich-poor len: 0
layer: 4; vertices: 15 17 16 11 8 15 ; rich-poor len: 5
layer: 5; vertices: 7 6 8 15-14 10 13 4 2 7 ; rich-poor len: 5




layer: 0; vertices: 14 15 8 11 9 1 6 7 2 4 5 3 0 14 ; rich-poor len: -1
layer: 1; vertices: 14 10 16 11 9 2 7 3 0 14 ; rich-poor len: -1
layer: 2; vertices: 14 15 17 16 10 14 ; rich-poor len: 5
layer: 3; vertices: 9 2 4 13 10 16 11 8 6 7 3 5 1 9 ; rich-poor len: 5
layer: 4; vertices: 12 13 10 14 0 12 ; rich-poor len: 5
layer: 5; vertices: 12 17 16 11 9 1 5 3 0 12 ; rich-poor len: -1

layer 0: +13 -5
layer 1: +9 -9
layer 2: -13 +5
layer 3: -5 +13
layer 4: +5 -8 -5
layer 5: +9 -9

а тут уже норм

layer: 0; vertices: 13 12 17 16 10 13 ; rich-poor len: 5
layer: 1; vertices: 5 4 13 12 17 15 8 6 1 5 ; rich-poor len: 5
layer: 2; vertices: 12 13 4 5 1 6 8 11 9 2 7 3 0 12 ; rich-poor len: -1
layer: 3; vertices: 12 17 15 14 0 12 ; rich-poor len: 5
layer: 4; vertices: 9 2 4 5 3 7 6 1 9 ; rich-poor len: 0
layer: 4; vertices: 15 17 16 11 8 15 ; rich-poor len: 5
layer: 5; vertices: 7 6 8 15 14 10 13 4 2 7 ; rich-poor len: 5

дифф = 0, чётность = 0



ладно
это плохая мера
что с учётом рёбер накрытых 4 раза, что без





- формулы для or всё равно нет, а хочется иметь
- и возможно надо понять
	почему очень часто s0 совпадает с odd_poor_full_cycles
20.05
если нельзя 4:
mindiff: 0; parity: 0
mindiff: 0; parity: 1
mindiff: 14; parity: 1
mindiff: 1; parity: 0
mindiff: 1; parity: 1
mindiff: 2; parity: 0
mindiff: 2; parity: 1
mindiff: 3; parity: 0
mindiff: 3; parity: 1
mindiff: 4; parity: 0
mindiff: 4; parity: 1
mindiff: 6; parity: 0
mindiff: 6; parity: 1
mindiff: 8; parity: 0
mindiff: 8; parity: 1
mindiff: 9; parity: 0
no best; parity: 0
no best; parity: 1


если можно:
mindiff: 0; parity: 0
mindiff: 0; parity: 1
mindiff: 1; parity: 0
mindiff: 1; parity: 1
mindiff: 2; parity: 0
mindiff: 2; parity: 1
mindiff: 4; parity: 0

ну или надо не на parity смотреть, а на что-то ещё

а с другой стороны!
на 20.05 на o6c4c
	mindiff с разрешёнными 4-накрытиями
	или 0, или 1
но на 22.05 уже бывают и 2, 4, 6
	зато если число oriented вершин = 0, то
	mindiff1 == 0
	mindiff2 == 0 или невозможен
	хотя всего 10 примеров
на 24.05
	mindiff1 = 0
	mindiff2 всякий
на 24.04
	на or = 0 есть mindiff1 = 1

отказываюсь от mindiff2, он какой-то рандомный

в общем
mindiff1 тоже выглядит плохой мерой

вообще до 24.04:
	mindiff1 бывает
	0,1,2,4,6
26.05:
	0,1,2,3,4,6,8


короче
mindiff1 можно тоже закопать
выглядит бесполезно


значит понятие "has 2 cdcs" как-то по-другому варьируется
другой вид обструкции


также проверил, что
	если зафиксировать граф, s0,s1,s2, то можно найти 2 разных решения с разными чётностями or
24.04:
g97: new o6c4c: or: 06; t1+t3: 16; s0: 16; s1: 28; s2: 1; t1: 2; PAR: 1 (1); mindiff: 0;
g97: new o6c4c: or: 07; t1+t3: 19; s0: 16; s1: 28; s2: 1; t1: 2; PAR: 1 (1); mindiff: 0;


opc2f = odd_poor_comps_full_cycles / 2
24.05:
g10: new o6c4c: or: 05; t1+t3: 14; s0: 14; s1: 27; s2: 2; t1: 1; opc2f: 2; PAR: 1 (1);
g10: new o6c4c: or: 02; t1+t3: 05; s0: 14; s1: 27; s2: 2; t1: 1; opc2f: 2; PAR: 1 (1); SEAL;

24.05
g10: new o6c4c: or: 06; t1+t3: 17; s0: 14; s1: 29; s2: 2; t1: 1; opc2f: 1; chords: 16 13 7; PAR: 1 (1);
g10: new o6c4c: or: 05; t1+t3: 15; s0: 14; s1: 29; s2: 2; t1: 0; opc2f: 1; chords: 16 13 7; PAR: 1 (1);

g12: new o6c4c: or: 06; t1+t3: 18; s0: 16; s1: 31; s2: 2; t1: 0; opc2f: 0; chords: 20 12 4; PAR: 1 (1);
g12: new o6c4c: or: 08; t1+t3: 22; s0: 16; s1: 31; s2: 2; t1: 2; opc2f: 0; chords: 20 12 4; PAR: 1 (1);
g12: new o6c4c: or: 08; t1+t3: 21; s0: 16; s1: 31; s2: 2; t1: 3; opc2f: 0; chords: 20 12 4; PAR: 1 (1);
g12: new o6c4c: or: 07; t1+t3: 18; s0: 16; s1: 31; s2: 2; t1: 3; opc2f: 0; chords: 20 12 4; PAR: 1 (1);
g12: new o6c4c: or: 09; t1+t3: 25; s0: 16; s1: 31; s2: 2; t1: 2; opc2f: 0; chords: 20 12 4; PAR: 1 (1);


- хотя можно попробовать ещё снять ограничение, что
	в каждом слое должны быть оба решения
	но тогда оба числа неинтересны
	они всегда будут нолями
	потому что в 1 часть можно сложить любые 3 слоя, а в другую - оставшиеся 3 слоя

	можно попробовать сделать так не более, чем в 2 слоях
	но лень



or + s0 + odd_poor_full_cycles
хочу 0
or == 0, or == 2 - всё ок
если 2 cdcs: s0 чётно, odd_poor_full_cycles = 0, or бывает разный
	ну вот, облом

тогда возможно я хочу
	s0 + odd_poor_full_cycles + что-нибудь, что приравняет это к 0
	такая формула работает на
	or = 0, or = 2, has 2 cdcs
	(то есть добавлять вообще ничего не надо)


возможно надо has 2 cdcs проварьировать так, что можно накрыть 2 или 4 раза
	ок, тестирую
	с ограничением на 2 части в одном слое - хрень
	без ограничения: тоже хрень
	окей




done:
	изучить кейсы, когда
	opc2f == op2f
	ничего интересного нету





давай ещё каждое o6c4c решение гляну на nz-mod5 и nz-mod6
24.05
	or=0 => 0,1
	or=2 => 0,1; 1,1
	or=3 => 0,0; 0,1; 1,1
	всё равно mod5=1, mod6=0 => s0 чётный, or >= 5
	1,1,0 - 3 кейса
	g9: new o6c4c: or: 07; t1+t3: 18; s0: 14; s1: 28; s2: 1; t1: 3; opc2f: 2; op2f: 2; PAR: 1 (1); mod5: 1; mod6: 1; both: 0;
	g14: new o6c4c: or: 05; t1+t3: 14; s0: 16; s1: 28; s2: 1; t1: 1; opc2f: 2; op2f: 2; PAR: 1 (1); mod5: 1; mod6: 1; both: 0;
	g14: new o6c4c: or: 07; t1+t3: 20; s0: 14; s1: 30; s2: 2; t1: 1; opc2f: 1; op2f: 1; PAR: 0 (0); mod5: 1; mod6: 1; both: 0;


24.04:
	s2 = 0
		все варианты
	s2 = 3:
		все варианты
	or = 0:
		0, 1
		1, 1
	or = 2:
		0, 0
		0, 1
		1, 1
	has 2 cdcs:
		все варианты
26.05:
	or = 0:
		0, 0
		0, 1
		1, 1
	or = 2:
		0, 0
		0, 1
		1, 1
 это наверно максимум, что я могу выжать интересного тут
 хотя я бы перепроверил на 28.05


 а нет!


надо глянуть для s0 нечётного
и для or == 0 и or == 2
	если есть веса для nzmod5 - подойдут ли они же, только для nzmod6?
24.05: это так
26.05 - да



смотри-ка
24.04, 26.05
	если
	nzmod5: 1; nzmod6: 0
	то 
		s0 - чётно
		or >= 3

	если 1,1,0:
		or >= 5 (5-9)
			28.05: 5-12
		s0 чётно (14,16,18)
			28.05: 12,14,16,18,20
		op2f не бывает 3
			28.05g2889: op2f: 3
			ломается на 28.05


то есть:
	такое ощущение, что если or = 0 или 2 или s0 чётно, то
	из nz-mod5 решения строится nz-mod6 решение по тем же весам
	а может и веса очень тупые?
	не, по разному, очень много вариаций

ой
у меня both кривой
по идее
я могу веса вообще до 59 брать
: /
хм хм хм
бесполезное понятие, надо думать
вот это both nz mod
ну типа
я могу просто любые 2 решения так скрестить


слушай
а можно ведь связать 6cdc и 5cdc в графе петерсена
	то есть я не очень явно понимаю как это сделать
	но 3 слоя из 5 можно сохранить
может так и попробовать сделать для бОльших снарков?
типа беру 6c4c, разлагающееся в 2 разных 6cdc
	и пытаюсь в каждом из них выделить 3 слоя
	и поискать 5cdc, в котором есть эти 3 слоя
у меня такое ощущение, что
	для петерсеновых 6c4c я спокойно найду нужные мне 5cdc


nz5, nz6
0, 0
0, 1
1, 1

24.05:
	ничего интересного не нашёл





проверить, что есть 5cdc с тремя совпадающими слоями-циклами
done
18.05 - всегда есть
20.05 - всегда есть
22.05 - всегда есть
чудеса какие-то
на 20.05 бывает, что только 2 5cdc подходят


done:
has 2 cdcs показывает подозрительно мало решений на графе петерсене
и на других снарках
всегда 2 решения, которые друг другу просто дополнительны
я ожидал в графе петерсена минимум 10 или 20 разложений в 2 cdcs
	а не, с петерсеном всё правильно
	взяв одну из цепей - я сразу блокирую соседнюю, а также ещё 5 цепей, которые проходят по тем же парам рёбер



разложение в 2 cdcs неединственно, ура
для того же 24.04g133 множество вариантов
 208 has 2 cdcs with 1 solutions
 172 has 2 cdcs with 2 solutions
  36 has 2 cdcs with 4 solutions
   6 has 2 cdcs with 8 solutions
возможно потому, что там бывают целые цепи из poor рёбер
но!
кажется, что число 2 cdcs решений - всегда степень двойки
- но как это доказать?
	какая тут комбинаторика?
- и кажется, что отсюда следует,
	что к "разложение в 2 cdcs" может и нет приближений никаких
	ну типа это не оптимизационная задача
ну и как выясняется, это очень-очень узкоспециализированные 2 6cdc,
которые конвертируемы в 2 5cdc



	если t1+t3 <= 8 (до 28.05+26.04):
->		parity == 1

		s2 не бывает 0
			сломалось на 30.05 на t1+t3==6

			что это за граф и какой у него oddness?



92 layer: 0; vertices: 0: 4 5 12 13 10 6 7 3 8 14 0 4
95 layer: 3; vertices: 6: 10 13 11 9 8 14 17 15 2 4 0 10
96 layer: 4; vertices: 8: 10 6 1 18 19 16 17 14 0 10
oriented: 1 3 4 13 17
здесь не может быть dominating чего-либо
	потому что 0 и 14 оба накрыты 3 раза
	поэтому они оба ignored
	а ещё 10

103 layer: 0; vertices: 1: 9-11-2-15 17 16 19 18 1-9
106 layer: 3; vertices: 7: 18-12-5-16-19-3 7 6 1-18
107 layer: 4; vertices: 9: 15-7-3 8 9 11 13 12 5 4 2 15



94 layer: 2; vertices: 5: 9 11 2 4 5 16 17 15 7 6 1 9
95 layer: 3; vertices: 6: 10 13 11 9 8 14 17 15 2 4 0 10
97 layer: 5; vertices: 11: 15 7 3 19 18 12 13 11 2 15
2 11
тоже соседи



layer: 0; vertices: 0: 18 23 22 11 9 17 8 14 0 18
layer: 1; vertices: 3: 5 4 12 25 13 9 17 16 15 14 8 3 7 2 24 11 22 10 19 6 1 5
layer: 2; vertices: 4: 20 21 12 25 24 11 9 13 15 14 0 20
layer: 2; vertices: 5: 16 17 8 3 5 4 2 7 6 1 16
layer: 3; vertices: 9: 20 21 23 22 10 20
layer: 4; vertices: 11: 16 15 13 25 24 2 4 12 21 23 18 19 6 7 3 5 1 16
layer: 5; vertices: 12: 20 10 19 18 0 20
some1: (nop 1: 0 2 5); total: 1
taken count: 7 vs 7
layers: 6 vs 6
has 5cdc with same triple: 1 0
find 2cdcs success
layer: 0; vertices: 1: 16 15 13 25 24 2 7 3 5 4 12 21 20 10 19 6 1 16
layer: 1; vertices: 2: 20 21 23 18 0 20
layer: 2; vertices: 6: 19 18 23 22 10 19
layer: 3; vertices: 7: 18 19 6 7 2 4 12 25 24 11 9 13 15 14 0 18
layer: 3; vertices: 8: 16 17 8 3 5 1 16
layer: 4; vertices: 10: 20 10 22 11 9 17 8 14 0 20
layer: 5; vertices: 13: 5 4 2 24 11 22 23 21 12 25 13 9 17 16 15 14 8 3 7 6 1 5
some1: total: 0
taken count: 7 vs 7
layers: 6 vs 6
has 5cdc with same triple: 0 1


layer: 0; 18 23 22 11 9 17 8 14 0 18
layer: 2; 20 21 12 25 24 11 9 13 15 14 0 20
layer: 2; 16 17 8 3 5 4 2 7 6 1 16
layer: 5; 20 10 19 18 0 20

layer: 0; 16.15.13.25.24.2.7.3~5-4-12~21~20~10-19-6~1~16
layer: 2; 19~18~23-22-10~19
layer: 5;  5~4~2.24~11~22~23-21-12~25.13.9.17.16.15.14.8.3.7~6-1-5

244 cycle:
23-21-12-4-5-1-6-19-10-22-23
16.15.14.8.3.7.2.24.25.13.9.17.16
fifth cycle:
16.15.13.25-12-21-20-10-19-18-23-22-11-24.2-4-5-3.7-6-1-16
прикол
это же 5cdc, не?
причём включающий нужный мне цикл?
а код говорит, что это невозможно
не, постой


давай сначала
мне нужно 5cdc, мне не нужно накрывать оставшиеся рёбра из слоёв 0,2,5

 -  1  -  -  4  5  6  -  -  -
10  - 12  -  -  -  -  -  - 19
 - 21 22 23  -  -


layer: 0; 18 23 22 11 9 17 8 14 0 18
layer: 2; 20 21 12 25 24 11 9 13 15 14 0 20
layer: 2; 16 17 8 3 5 4 2 7 6 1 16
layer: 5; 20 10 19 18 0 20
244 cycle:
23-21-12-4-5-1-6-19-10-22-23
24~25.13~9~17~16.15~14~8~3.7~2.24
fifth cycle:
19-6~7.3~5-1~16.15~13.25~12-4~2.24~11~22-10~20~21-23~18~19

во
я получил 5cdc
честно
не совпадает с верхним
там есть рёбра, накрытые 3 разу, тут нет
(хотя надо признать слой 244 cycle тот же самый (интересно, можно ли это формализовать, но это уже перебор)
отличие в fifth cycle)

то есть моя мысль такая, что
	надо выписать - сколько ещё каждое ребро должно встретиться раз, 0, 1 или 2
	и тогда уже буду накрывать


after 244 cycle
1:  16(1)  5(1)
2:   7(1)  4(1) 24(2)
3:   8(1)  5(1)  7(2)
4:  12(1)
6:  19(1)  7(1)
8:  14(1)
9:  13(1) 17(1)
10: 20(1) 22(1)
11: 24(1) 22(1)
12: 25(1)
13: 15(1) 25(2)
14: 15(1)
15: 16(2)
16: 17(1)
18: 23(1) 19(1)
20: 21(1)
21: 23(1)
24: 25(1)


before 244 cycle
1:  16(1)  5(2)  6(1)
2:   7(1)  4(1) 24(2)
3:   8(1)  5(1)  7(2)
4:  12(2)  5(1)
6:  19(2)  7(1)
8:  14(1)
9:  13(1) 17(1)
10: 20(1) 19(1) 22(2)
11: 24(1) 22(1)
12: 21(1) 25(1)
13: 15(1) 25(2)
14: 15(1)
15: 16(2)
16: 17(1)
18: 23(1) 19(1)
20: 21(1)
21: 23(2)
22: 23(1)
24: 25(1)


g10
0:  20(e0)  18(e1)  14(e2)
1:  16(e3)   5(e4)   6(e5)
2:   7(e6)   4(e7)  24(e8)
3:   8(e9)   5(e10)  7(e11)
4:  12(e12)  5(e13)
6:  19(e14)  7(e15)
8:  14(e16) 17(e17)
9:  13(e18) 11(e19) 17(e20)
10: 20(e21) 19(e22) 22(e23)
11: 24(e24) 22(e25)
12: 21(e26) 25(e27)
13: 15(e28) 25(e29)
14: 15(e30)
15: 16(e31)
16: 17(e32)
18: 23(e33) 19(e34)
20: 21(e35)
21: 23(e36)
22: 23(e37)
24: 25(e38)




9476
9314

all 5cdc solutions: 44184
all 5cdc solutions: 35478
all 5cdc solutions: 36308
all 5cdc solutions: 36899
all 5cdc solutions: 35500
all 5cdc solutions: 33432
здесь больше решений не стало после исправления


all 5cdc solutions: 135950
all 5cdc solutions: 123948
all 5cdc solutions: 135682
all 5cdc solutions: 131962
all 5cdc solutions: 122944
all 5cdc solutions: 113188
all 5cdc solutions: 129000
all 5cdc solutions: 113792
all 5cdc solutions: 133306
all 5cdc solutions: 133306
all 5cdc solutions: 132424
all 5cdc solutions: 126028
all 5cdc solutions: 141558
all 5cdc solutions: 132424
all 5cdc solutions: 141558
all 5cdc solutions: 128114
all 5cdc solutions: 151914
all 5cdc solutions: 152366
all 5cdc solutions: 127768
all 5cdc solutions: 126028



should be:
???




26.05g10
layer 0:
18, 23, 22, 11, 9, 17, 8, 14, 0, 18

layer 1:
20, 21, 12, 25, 24, 11, 9, 13, 15, 14, 0, 20
16, 17, 8, 3, 5, 4, 2, 7, 6, 1, 16

layer 2:
20, 10, 19, 18, 0, 20

244 cycle:
23, 21, 12, 4, 5, 1, 6, 19, 10, 22, 23
24, 25, 13, 9, 17, 16, 15, 14, 8, 3, 7, 2, 24

fifth cycle:
19, 6, 7, 3, 5, 1, 16, 15, 13, 25, 12, 4, 2, 24, 11, 22, 10, 20, 21, 23, 18, 19


йеееее
я исправил багу в 5cdc!


так, надо перепроверять
на 24.05g12 нашлось такое
some1: (nop )(nop )(nop )(nop )total: 4
some1: (nop 1: 0 1 3); (nop 1: 0 2 4); (nop 1: 1 4 5); (nop 1: 2 3 5); total: 4
всё ещё есть такое

следующая цель: total == 0
так, надо перепроверять
да, на 26.05 ломается
(хоть это и после ускорения 5cdc)
has 5cdc with same triple: 0 0
has 5cdc with same triple: 0 1
has 5cdc with same triple: 1 0
has 5cdc with same triple: 1 1
так
этим выкладкам доверять нельзя





g1: another 6c4c: profile: rrrprrprrrrrrrppprrrpprppprprrprpprrrpp; s0= 14; s1= 23; s2= 0; par: 1; comps: 3 6;
find 2cdcs success
layer: 0; vertices: 0: 14 15 3 8 0 14
layer: 1; vertices: 3: 5 3 15 7 16 17 11 20 23 22 25 13 12 10 24 6 1 5
layer: 2; vertices: 5: 4 14 15 7 6 24 25 13 9 19 17 16 18 21 20 11 2 4
layer: 3; vertices: 6: 12 13 9 8 0 12
layer: 3; vertices: 7: 22 25 24 10 23 20 21 19 17 11 2 18 16 7 6 1 22
layer: 4; vertices: 10: 18 21 19 9 8 3 5 4 2 18
layer: 5; vertices: 11: 12 10 23 22 1 5 4 14 0 12
some1: (nop 1: 0 3 4); total: 1
taken count: 7 vs 7
layers: 6 vs 6
has 5cdc with same triple: 1 0
find 2cdcs success
layer: 0; vertices: 1: 5 4 2 11 17 19 9 13 12 10 24 25 22 23 20 21 18 16 7 6 1 5
layer: 1; vertices: 2: 14 4 2 18 21 19 9 8 0 14
layer: 2; vertices: 4: 12 10 23 22 1 5 3 8 0 12
layer: 3; vertices: 8: 5 4 14 15 3 5
layer: 4; vertices: 9: 12 13 25 22 1 6 24 10 23 20 11 17 16 7 15 14 0 12
layer: 5; vertices: 12: 18 16 17 19 21 20 11 2 18
layer: 5; vertices: 13: 8 9 13 25 24 6 7 15 3 8
some1: total: 0
taken count: 7 vs 7
layers: 6 vs 6
has 5cdc with same triple: 0 1


----

26.05g1

layer: 0; vertices: 0: 14 15 3 8 0 14
layer: 3; vertices: 6: 12 13 9 8 0 12
layer: 3; vertices: 7: 22 25 24 10 23 20 21 19 17 11 2 18 16 7 6 1 22
layer: 4; vertices: 10: 18 21 19 9 8 3 5 4 2 18

244-cycle:
22-23-20-11-17-16-7-15-14-4-5-1-6-24-10-12-13-25-22

fifth cycle:
11-20-21-18-16-17-19-9-13-25-24-6-7-15-3-5-1-22-23-10-12-0-14-4-2-11


 -  1  -  -  4  5  6  7  -  -
10 11 12 13 14 15 16 17  -  -
20  - 22 23 24 25

но я опять смог собрать 5cdc!

after 244
0:  12(1) 14(1)
1:  22(1)  5(1)
2:   4(1) 11(1)
3:   5(1) 15(1)
4:  14(1)
6:  24(1)  7(1)
7:  15(1)
9:  13(1) 19(1)
10: 12(1) 23(1)
11: 20(1)
13: 25(1)
16: 18(1) 17(1)
17: 19(1)
18: 21(1)
20: 21(1)
22: 23(1)
24: 25(1)


before 244
0:  12(1) 14(1)
1:  22(1)  5(2)  6(1)
2:   4(1) 11(1)
3:   5(1) 15(1)
4:  14(2)  5(1)
6:  24(2)  7(1)
7:  16(1) 15(2)
9:  13(1) 19(1)
10: 12(2) 24(1) 23(1)
11: 17(1) 20(2)
12: 13(1)
13: 25(2)
14: 15(1)
16: 18(1) 17(2)
17: 19(1)
18: 21(1)
20: 23(1) 21(1)
22: 25(1) 23(2)
24: 25(1)


before
0:  12(2) 14(2)  8(2)
1:  22(2)  5(2)  6(2)
2:  18(2)  4(2) 11(2)
3:   8(2)  5(2) 15(2)
4:  14(2)  5(2)
6:  24(2)  7(2)
7:  16(2) 15(2)
8:   9(2)
9:  13(2) 19(2)
10: 12(2) 24(2) 23(2)
11: 17(2) 20(2)
12: 13(2)
13: 25(2)
14: 15(2)
16: 18(2) 17(2)
17: 19(2)
18: 21(2)
19: 21(2)
20: 23(2) 21(2)
22: 25(2) 23(2)
24: 25(2)



в 5cdc есть бага
а именно
неправильно ведётся учёт в
edge_count_in_5cdc
но как? вроде правильно
всё, ура
убрал багу
почему-то в коде было
int vertex_count_in_5cdc[MAXN / 2];



перепроверяю o6c4c, 2-6cdc, nop, ins, total == 0
ага, до 20 включительно можно не проверять, там ничего не изменится
ломалось начиная с 24

26.05g1
5cdc: 1605368

22.05g12: получил то же, что было



layer: 0; vertices: 0: 14 15 17 16 0 14
layer: 0; vertices: 2: 21 18 19 7 6 21
layer: 1; vertices: 4: 9 11 10 12 13 17 15 2 22 19 18 1 9
layer: 2; vertices: 6: 12 13 4 14 0 12
layer: 2; vertices: 7: 5 3 20 23 21 18 1 5
layer: 3; vertices: 10: 8 16 17 13 4 5 3 8
layer: 3; vertices: 11: 19 22 23 20 7 19
layer: 4; vertices: 12: 12 10 6 21 23 22 2 11 9 8 16 0 12
layer: 5; vertices: 16: 9 8 3 20 7 6 10 11 2 15 14 4 5 1 9
some1: (nop 1: 0 1 3); (nop 1: 0 2 4); (nop 1: 1 4 5); (nop 1: 2 3 5); total: 4
taken count: 9 vs 9
layers: 6 vs 6
has 5cdc with same triple: 1 1
find 2cdcs success
layer: 0; vertices: 1: 9 8 3 20 23 22 2 11 10 12 13 4 5 1 9
layer: 1; vertices: 3: 14 4 5 3 8 16 0 14
layer: 1; vertices: 5: 21 23 20 7 6 21
layer: 2; vertices: 8: 22 19 7 6 10 11 9 8 16 17 15 2 22
layer: 3; vertices: 9: 12 10 6 21 18 1 9 11 2 15 14 0 12
layer: 4; vertices: 13: 5 3 20 7 19 18 1 5
layer: 4; vertices: 14: 14 15 17 13 4 14
layer: 5; vertices: 15: 12 13 17 16 0 12
layer: 5; vertices: 17: 21 23 22 19 18 21
some1: (nop 1: 0 1 4); (nop 1: 0 2 3); (nop 1: 1 3 5); (nop 1: 2 4 5); total: 4


вопрос: дурацкий правда
может ли быть так, что слои из 2-6cdc, которые первые 3
давайте их тоже на самом деле достроим
или попробуем внутрь них пихнуть цикл из 244-flows
да, дурацкий - здесь это не поможет

24.05g12

layer: 0; vertices: 0: 14 15 17 16 0 14
layer: 0; vertices: 2: 21 18 19 7 6 21
layer: 1; vertices: 4: 9 11 10 12 13 17 15 2 22 19 18 1 9
layer: 3; vertices: 10: 8 16 17 13 4 5 3 8
layer: 3; vertices: 11: 19 22 23 20 7 19


vs


layer: 0; vertices: 1: 9 8 3 20 23 22 2 11 10 12 13 4 5 1 9
layer: 1; vertices: 3: 14 4 5 3 8 16 0 14
layer: 1; vertices: 5: 21 23 20 7 6 21
layer: 3; vertices: 9: 12 10 6 21 18 1 9 11 2 15 14 0 12


244-flows:
23-21-6-10-12-0-14-4-5-1-9-8-3-20-23
так, хорошо, этот цикл не впихнёшь в первые 3
теперь надо понять, почему не строится пятый цикл
	наверно проблема будет в том, что надо вершину 2 ещё покрыть?
	да, именно в этом проблема оказалась
	ребро 2-11 висит и никем не покрыто
fifth cycle:
2-15-14-4-13-12-0-16-8-9-11-10-6-7-20-3-5-1-18-21-23-22-2
 x  x  -  x  x  x  x  -  8  9
 x  -  x  -  x  -  -  -  -  -
 x  x  -  x


2: 11(2)


 0  1  -  3  4  5  6  -  8  9
10  - 12  - 14  -  -  -  -  -
20 21  - 23


after 244-flows
0:  12(1) 16(1)
1:   5(1) 18(1)
2:  22(1) 15(1) 11(2)
3:   5(1) 20(1)
4:  14(1) 13(1)
6:  10(1)  7(1)
7:  20(1)
8:  16(1)  9(1)
9:  11(1)
10: 11(1)
12: 13(1)
14: 15(1)
18: 21(1)
21: 23(1)
22: 23(1)




before 244-flows
0:  12(2) 14(1) 16(1)
1:   9(1)  5(2) 18(1)
2:  22(1) 15(1) 11(2)
3:   8(1)  5(1) 20(2)
4:  14(2) 13(1)  5(1)
6:  10(2) 21(1)  7(1)
7:  20(1)
8:  16(1)  9(2)
9:  11(1)
10: 12(1) 11(1)
12: 13(1)
14: 15(1)
18: 21(1)
20: 23(1)
21: 23(2)
22: 23(1)


0:  12(2) 14(2) 16(2)
1:   9(2)  5(2) 18(2)
2:  22(2) 15(2) 11(2)
3:   8(2)  5(2) 20(2)
4:  14(2) 13(2)  5(2)
6:  10(2) 21(2)  7(2)
7:  19(2) 20(2)
8:  16(2)  9(2)
9:  11(2)
10: 12(2) 11(2)
12: 13(2)
13: 17(2)
14: 15(2)
15: 17(2)
16: 17(2)
18: 21(2) 19(2)
19: 22(2)
20: 23(2)
21: 23(2)
22: 23(2)



0:  12(e0)  14(e1)  16(e2)
1:   9(e3)   5(e4)  18(e5)
2:  22(e6)  15(e7)  11(e8)
3:   8(e9)   5(e10) 20(e11)
4:  14(e12) 13(e13)  5(e14)
6:  10(e15) 21(e16)  7(e17)
7:  19(e18) 20(e19)
8:  16(e20)  9(e21)
9:  11(e22)
10: 12(e23) 11(e24)
12: 13(e25)
13: 17(e26)
14: 15(e27)
15: 17(e28)
16: 17(e29)
18: 21(e30) 19(e31)
19: 22(e32)
20: 23(e33)
21: 23(e34)
22: 23(e35)






todo:
	перепроверить результаты про 5cdc при числе вершин >= 24,
		если у меня вообще есть эти результаты


а вот total = 0 будет сложнее проверять,
потому что 5cdc на 26.05 очень медленный,
скорее придётся поступить по-другому:
	




степени двойки:
g2: another 6c4c: profile: ppprrrrpprppprrrrrppprpppprrrrrrp; s0= 15; s1= 17; s2= 0; par: 0; comps: 2 2;
find 2cdcs success
layer: 0; vertices: 0: 20 p 21 p 9 p 13 p 12 p 4 r 5 r 16 r 19 r 18 r 10 p 11 p 2 r 7 p 3 r 8 p 0 p 20
layer: 1; vertices: 3: 14 r 17 r 19 r 16 r 1 r 14
layer: 2; vertices: 5: 10 r 18 r 6 r 1 r 14 r 13 p 9 p 8 p 0 p 10
layer: 2; vertices: 6: 4 p 12 p 20 p 21 p 11 p 2 p 4
layer: 3; vertices: 9: 18 r 19 r 17 r 15 r 6 r 18
layer: 4; vertices: 11: 16 r 5 p 3 p 7 r 15 r 6 r 1 r 16
layer: 5; vertices: 13: 10 p 11 p 21 p 9 p 8 r 3 p 5 r 4 p 2 r 7 r 15 r 17 r 14 r 13 p 12 p 20 p 0 p 10
some1: total: 0
taken count: 7 vs 8
layers: 6 vs 6
find 2cdcs success
layer: 0; vertices: 0: 20 p 21 p 9 p 13 p 12 p 4 r 5 r 16 r 19 r 18 r 10 p 11 p 2 r 7 p 3 r 8 p 0 p 20
layer: 1; vertices: 3: 14 r 17 r 19 r 16 r 1 r 14
layer: 2; vertices: 5: 10 r 18 r 6 r 1 r 14 r 13 p 9 p 8 p 0 p 10
layer: 3; vertices: 9: 18 r 19 r 17 r 15 r 6 r 18
layer: 4; vertices: 11: 16 r 5 p 3 p 7 r 15 r 6 r 1 r 16
layer: 4; vertices: 12: 4 p 12 p 20 p 21 p 11 p 2 p 4
layer: 5; vertices: 13: 10 p 11 p 21 p 9 p 8 r 3 p 5 r 4 p 2 r 7 r 15 r 17 r 14 r 13 p 12 p 20 p 0 p 10
some1: total: 0
taken count: 7 vs 8
layers: 6 vs 6
find 2cdcs success
layer: 0; vertices: 1: 14 r 17 r 15 r 6 r 1 r 14
layer: 1; vertices: 2: 20 p 21 p 9 p 13 p 12 p 4 r 5 p 3 r 8 p 0 p 20
layer: 1; vertices: 4: 7 r 15 r 6 r 18 r 10 p 11 p 2 r 7
layer: 2; vertices: 6: 4 p 12 p 20 p 21 p 11 p 2 p 4
layer: 2; vertices: 7: 5 r 16 r 19 r 17 r 15 r 7 p 3 p 5
layer: 3; vertices: 8: 10 p 11 p 21 p 9 p 8 r 3 p 7 r 2 p 4 r 5 r 16 r 1 r 14 r 13 p 12 p 20 p 0 p 10
layer: 4; vertices: 10: 10 r 18 r 19 r 17 r 14 r 13 p 9 p 8 p 0 p 10
layer: 5; vertices: 14: 16 r 19 r 18 r 6 r 1 r 16
some1: total: 0
taken count: 8 vs 7
layers: 6 vs 6
find 2cdcs success
layer: 0; vertices: 1: 14 r 17 r 15 r 6 r 1 r 14
layer: 1; vertices: 2: 20 p 21 p 9 p 13 p 12 p 4 r 5 p 3 r 8 p 0 p 20
layer: 1; vertices: 4: 7 r 15 r 6 r 18 r 10 p 11 p 2 r 7
layer: 2; vertices: 7: 5 r 16 r 19 r 17 r 15 r 7 p 3 p 5
layer: 3; vertices: 8: 10 p 11 p 21 p 9 p 8 r 3 p 7 r 2 p 4 r 5 r 16 r 1 r 14 r 13 p 12 p 20 p 0 p 10
layer: 4; vertices: 10: 10 r 18 r 19 r 17 r 14 r 13 p 9 p 8 p 0 p 10
layer: 4; vertices: 12: 4 p 12 p 20 p 21 p 11 p 2 p 4
layer: 5; vertices: 14: 16 r 19 r 18 r 6 r 1 r 16
some1: total: 0
taken count: 8 vs 7
layers: 6 vs 6
has 2 cdcs with 2

первое разбиение
0, 3, 5 6, 9, 11   , 13 vs 1, 2 4,   7, 8, 10 12, 14
0, 3, 5  , 9, 11 12, 13 vs 1, 2 4, 6 7, 8, 10   , 14

layer: 2; vertices: 6:  4 p 12 p 20 p 21 p 11 p 2 p 4
layer: 4; vertices: 12: 4 p 12 p 20 p 21 p 11 p 2 p 4

ну понятно, да



проверить, что есть 5cdc
	с сохранением трёх слоёв,
		что в одном из новых слоёв будет dominating circuit
		который проходит через все oriented вершины
	18.05: всегда находится
	20.05: полно решений, где нет dominating circuit
	ну ок


nah, 2 6cdc:
	эти разложения чуть более специфичные, чем я думаю
	кажется должно быть несложно показать, что
	если у первой половины есть 5cdc,
	то у второй тоже будет
	я глянул 20.05
	и глянул что там с dominating circuit
	и если смотреть на вторую половину, то она работает по принципу дополнения
	dom 1: (yep 1: 0 1 2); (nop 1: 0 1 5); (nop nop 2: 0 2 3); (nop 1: 0 3 4); (yep 1: 0 4 5);
	dom 2: (yep 1: 3 4 5); (nop 1: 2 3 4); (nop nop 2: 1 4 5); (nop 1: 1 2 5); (yep 1: 1 2 3);
	dom 1: (nop nop 2: 1 2 4);     (nop 1: 1 3 4); (nop nop 2: 1 3 5); (nop yep 2: 2 3 5); (nop 1: 2 4 5);
	dom 2: (nop nop 2: 0 3 5); (yep nop 2: 0 2 5); (nop nop 2: 0 2 4);     (nop 1: 0 1 4); (nop 1: 0 1 3);
	хм
	как видно - не совсем
	но почти
	всё равно вроде красиво и убедительно
	не, облом
	бывает вот так
	dom 1: (yep nop 2: 0 1 3); (yep 1: 0 1 4); (nop nop 2: 0 2 4); (yep 1: 0 2 5);
	dom 2:     (nop 1: 2 4 5); (yep 1: 2 3 5); (nop 1: 1 3 5);     (yep 1: 1 3 4);
	dom 1: (yep 1: 0 3 5); (nop 1: 1 2 3); (yep 1: 1 2 5);     (nop 1: 1 4 5); (nop 1: 2 3 4); (yep 1: 3 4 5);
	dom 2: (yep 1: 1 2 4); (nop 1: 0 4 5); (yep 1: 0 3 4); (yep yep 2: 0 2 3); (nop 1: 0 1 5); (yep 1: 0 1 2);
	кстати, тут же
	11 5cdc vs 12 5cdc


6c4c, 2 6cdc:
	правда ли, что some1count == some2count?
	(я считаю тройки, число самих подходящих 5cdc может отличаться, есть пример выше на 20.05)
	18.05, 20.05 - да

	причём надо будет проверить не просто, что some1count == some2count,
	а что тройки входят в противоположности всегда
	
	на 22.05 есть контрпример
	g4
	7 vs 8
	some1: (1: 0 1 5); (1: 0 2 4); (1: 0 3 4); (2: 0 3 5); (1: 1 2 3);             (2: 2 3 5); (1: 2 4 5);
	some2: (1: 2 3 4); (1: 1 3 5); (1: 1 2 5); (2: 1 2 4); (1: 0 4 5); (1: 0 2 5); (2: 0 1 4); (1: 0 1 3);
	
ну или же у меня есть ещё баги в 5cdc

layer: 1; vertices: 2: 12 r 13 r 17 r 16 r 0 r 12
layer: 3; vertices: 7: 18 p 21 p 20 p 7 p 19 r 2 r 11 r 9 p 8 p 3 p 5 r 4 r 13 r 12 p 10 r 6 p 1 p 18
layer: 4; vertices: 9: 5 p 3 r 7 p 20 p 6 p 1 r 5
да, тут точно нет 5cdc:
2:  15(2)
14: 15(2)
15: 17(2)
нужно в 2 слоях такое провернуть - это невозможно:
	в обоих циклах будет кусок -17-15-14-
это потому что вершины 15 вообще нет в этих трёх слоях
а это обязательно нужно в 5cdc

0:  12(1) 14(2) 16(1)
1:  18(1)  5(1)
2:  19(1) 15(2) 11(1)
3:   8(1)  7(1)
4:  14(2) 13(1)  5(1)
6:  10(1) 20(1)
7:  19(1)
8:  16(2)  9(1)
9:  21(2) 11(1)
10: 12(1) 11(2)
13: 17(1)
14: 15(2)
15: 17(2)
16: 17(1)
18: 21(1) 19(2)
20: 21(1)

layer: 1; vertices: 2: 12 r 13 r 17 r 16 r 0 r 12
layer: 3; vertices: 7: 18 p 21 p 20 p 7 p 19 r 2 r 11 r 9 p 8 p 3 p 5 r 4 r 13 r 12 p 10 r 6 p 1 p 18
layer: 4; vertices: 9: 5 p 3 r 7 p 20 p 6 p 1 r 5

vs

layer: 1; vertices: 3: 18 p 21 p 20 p 7 p 19 r 2 p 15 r 14 r 4 r 5 p 3 p 8 p 9 r 11 r 10 r 6 p 1 p 18
layer: 3; vertices: 6: 14 r 15 r 17 r 16 r 0 r 14
layer: 4; vertices: 8: 12 p 10 r 11 r 2 r 19 p 18 p 21 r 9 p 8 r 16 r 0 r 12



0:  12(2) 14(2) 16(2)
1:  18(2)  5(2)  6(2)
2:  19(2) 15(2) 11(2)
3:   8(2)  5(2)  7(2)
4:  14(2) 13(2)  5(2)
6:  10(2) 20(2)
7:  19(2) 20(2)
8:  16(2)  9(2)
9:  21(2) 11(2)
10: 12(2) 11(2)
12: 13(2)
13: 17(2)
14: 15(2)
15: 17(2)
16: 17(2)
18: 21(2) 19(2)
20: 21(2)


0:  12(e0)  14(e1)  16(e2)
1:  18(e3)   5(e4)   6(e5)
2:  19(e6)  15(e7)  11(e8)
3:   8(e9)   5(e10)  7(e11)
4:  14(e12) 13(e13)  5(e14)
6:  10(e15) 20(e16)
7:  19(e17) 20(e18)
8:  16(e19)  9(e20)
9:  21(e21) 11(e22)
10: 12(e23) 11(e24)
12: 13(e25)
13: 17(e26)
14: 15(e27)
15: 17(e28)
16: 17(e29)
18: 21(e30) 19(e31)
20: 21(e32)


24.05g17:
yepinsnopdiffs: -1 0 -1
some1:     (nop 1: 0 1 4); (nop nop 2: 0 1 5);     (nop 1: 0 2 3);     (nop 1: 0 2 4);
some2: (yep nop 2: 2 3 5);     (nop 1: 2 3 4); (nop nop 2: 1 4 5); (nop nop 2: 1 3 5);
some1: (nop 1: 0 3 5); (nop 1: 1 2 3); (nop nop 2: 1 2 5); (nop nop 2: 1 3 4); (nop 1: 2 4 5); (yep 1: 3 4 5);
some2: (nop 1: 1 2 4); (nop 1: 0 4 5);     (nop 1: 0 3 4); (nop nop 2: 0 2 5); (nop 1: 0 1 3); (yep 1: 0 1 2); 


2 6cdcs to 5cdcs:
связей между первой и второй половиной не нашёл
(половины - это 5cdc решения)
(могут разниться:
	число решений с dominating circuit,
	число решений 5cdc вообще,
	число троек, допускающих 5cdc
нужно ещё проверить по 244-flow циклу
	посчитать число решений yep, ins, yep+ins, nop
	18.05: nop могут различаться, yep всегда 10
	20.05: (yep1, ins1) и (yep2, ins2) совпадают
	22.05: тоже совпадают
	24.05: yep сломался
		наверно ins тоже где-нибудь сломается, но на 24.05 ins1 == ins2

	#ну вот и связь!
	#мб это легко доказать? скорее всего да
	#	потому что этот 244-цикл симметричный же
	#	про yep у меня интуиция на уровне
	#		для заданной тройки yep максимум 1 может быть
	#		точнее yep nop nop ... nop
	#       это очевидно - если есть yep, то я зафиксировал 4 слоя из 5
	#	хотя про ins у меня нет интуиции
	#		и их больше 1 бывает
)

done:
2 6cdcs to 5cdcs, ins, степени двойки:
- проверить, что ins появляются только в решениях, где
	число разложений больше 1
	не, неправда
	
24.05g5:
find 2cdcs success
layer: 0; vertices: 0: 14 r 15 r 17 r 16 r 0 r 14
layer: 1; vertices: 3: 15 r 17 r 13 r 12 p 10 r 6 p 7 p 19 p 18 p 22 r 9 r 11 r 2 p 15
layer: 2; vertices: 4: 12 r 13 r 4 r 14 r 0 r 12
layer: 2; vertices: 5: 5 p 3 r 21 p 23 p 20 p 1 r 5
layer: 3; vertices: 8: 18 p 22 p 23 p 21 p 19 p 7 r 2 p 15 r 14 r 4 r 5 p 3 p 8 p 9 r 11 r 10 r 6 p 20 p 1 p 18
layer: 4; vertices: 9: 12 p 10 r 11 r 2 r 7 p 6 p 20 p 23 p 22 r 9 p 8 r 16 r 0 r 12
layer: 5; vertices: 13: 18 p 19 p 21 r 3 p 8 r 16 r 17 r 13 r 4 r 5 r 1 p 18
some1: (nop 1: 0 1 3); (nop 1: 0 2 3); (nop 1: 0 4 5); (nop 1: 1 2 4); (nop 1: 1 2 5); (ins ins 2: 1 3 4); (nop 1: 2 3 5); (nop nop 2: 3 4 5); total: 8
some2: (nop nop 2: 0 1 2); (nop 1: 0 1 4); (ins ins 2: 0 2 5); (nop 1: 0 3 5); (nop 1: 1 2 3); (nop 1: 1 4 5); (nop 1: 2 4 5);
yepinsnops: 0 2 2 vs 0 2 2
yepinsnopdiffs: 0 0 0
taken count: 7 vs 7
layers: 6 vs 6
has 5cdc with same triple: 1 1
find 2cdcs success
layer: 0; vertices: 1: 18 p 22 p 23 p 21 p 19 p 7 r 2 r 11 r 9 p 8 p 3 p 5 r 4 r 13 r 12 p 10 r 6 p 20 p 1 p 18
layer: 1; vertices: 2: 14 r 4 r 5 r 1 p 20 p 23 p 21 r 3 p 8 r 16 r 0 r 14
layer: 2; vertices: 6: 15 r 17 r 16 r 8 p 9 r 22 p 18 p 19 p 7 p 6 r 10 r 11 r 2 p 15
layer: 3; vertices: 7: 12 r 13 r 17 r 16 r 0 r 12
layer: 4; vertices: 10: 18 p 19 p 21 r 3 p 5 r 1 p 18
layer: 4; vertices: 11: 14 r 15 r 17 r 13 r 4 r 14
layer: 5; vertices: 12: 12 p 10 r 11 r 9 r 22 p 23 p 20 p 6 p 7 r 2 p 15 r 14 r 0 r 12
some1: (nop nop 2: 0 1 2); (nop 1: 0 1 4); (ins ins 2: 0 2 5); (nop 1: 0 3 5); (nop 1: 1 2 3); (nop 1: 1 4 5); (nop 1: 2 4 5); total: 7
some2: (nop 1: 0 1 3); (nop 1: 0 2 3); (nop 1: 0 4 5); (nop 1: 1 2 4); (nop 1: 1 2 5); (ins ins 2: 1 3 4); (nop 1: 2 3 5); (nop nop 2: 3 4 5);
yepinsnops: 0 2 2 vs 0 2 2
yepinsnopdiffs: 0 0 0
taken count: 7 vs 7
layers: 6 vs 6
has 5cdc with same triple: 1 1
has 2 cdcs with 1

layer: 1; vertices: 3: 15 r 17 r 13 r 12 p 10 r 6 p 7 p 19 p 18 p 22 r 9 r 11 r 2 p 15
layer: 3; vertices: 8: 18 p 22 p 23 p 21 p 19 p 7 r 2 p 15 r 14 r 4 r 5 p 3 p 8 p 9 r 11 r 10 r 6 p 20 p 1 p 18
layer: 4; vertices: 9: 12 p 10 r 11 r 2 r 7 p 6 p 20 p 23 p 22 r 9 p 8 r 16 r 0 r 12

vs

layer: 1; vertices: 2: 14 r 4 r 5 r 1 p 20 p 23 p 21 r 3 p 8 r 16 r 0 r 14
layer: 3; vertices: 7: 12 r 13 r 17 r 16 r 0 r 12
layer: 4; vertices: 10: 18 p 19 p 21 r 3 p 5 r 1 p 18
layer: 4; vertices: 11: 14 r 15 r 17 r 13 r 4 r 14

244-flows:
17-r-16-r-0-r-14-r-4-r-13-r-17

 0  -  -  -  4  -  -  -  -  -
 -  -  - 13 14  - 16 17  -  -
 -  -  -  -



done, 6c4c, инвариант:
	кстати
	глянуть на решения, где есть полностью poor цепи
	там есть интересные закономерности?
	пока что единственное что есть
	до 24.05
	odd_poor_full_cycles != 3
	odd_poor_full_cycles == 1 очень редко и специфично
	на 26.05 odd_poor_full_cycles == 1 побольше
	на 26.05 есть g92, где odd_poor_full_cycles == 3
	ну всё, done



done: 	
	winding number
	для o5cdc с dominating circuit
	отдебажил, ура
	18.05: 3-6
	20.05: 2-6
	22.05: 1-8
	а, во, интересное наблюдение!
	winding number зависит от самой цепи, не зависит от решения
		проверил до 20.05
	на 22.05g5 это не так
		и там у одной dominating цепи бывают winding 6 и 7
	надо глянуть, что это, чтоб убедиться, что это не бага в вычислениях

	22.05
	g5 windings: 3745471493; 6 7

	g9 windings: 6885132149; 3 4
	g9 windings: 6885202483; 3 4
	
	g10 windings: 5942200181; 3 4
	g10 windings: 5942270515; 3 4

	24.05
	g2 windings: 56754657192; 6 8
	g2 windings: 56813288280; 6 8
	g2 windings: 57805503296; 6 8
	g2 windings: 63174072192; 6 8

	g8 windings: 51244886531; 6 8

	g22 windings: 31249059227; 5 6
	g22 windings: 31249125597; 5 6

	g32 windings: 47536064373; 3 4
	g32 windings: 47536134707; 3 4

	g33 windings: 45191450035; 3 4
	g33 windings: 45191516405; 3 4

	g36 windings: 64111613470; 6 7
	g36 windings: 66260096542; 6 7
	g36 windings: 66996861469; 6 7
	g36 windings: 67005242395; 6 7


layer: 0; circ: 0; or: 0; 12 10 6 18 1 9 8 3 7 2 15 14 0 12
layer: 1; circ: 1; or: 1; DOM (3745471493); 12 0 16 8 9 11 21 19 18 6 20 7 3 5 4 14 15 17 13 12
layer: 2; circ: 2; or: 0; 14 4 13 17 16 0 14
layer: 3; circ: 3; or: 1; 9 1 5 3 8 16 17 15 2 19 21 20 6 10 11 9
layer: 4; circ: 4; or: 1; 5 1 18 19 2 7 20 21 11 10 12 13 4 5
ws: 2 ws: 1 ws: 2 ws: 1 ; total: 6


layer: 0; circ: 0; or: 0; 12 10 11 9 1 18 19 2 15 14 0 12
layer: 1; circ: 1; or: 1; DOM (3745471493); 12 0 16 8 9 11 21 19 18 6 20 7 3 5 4 14 15 17 13 12
layer: 2; circ: 2; or: 0; 14 4 13 17 16 0 14
layer: 3; circ: 3; or: 0; 9 8 3 7 2 19 21 20 6 10 12 13 4 5 1 9
layer: 4; circ: 4; or: 0; 5 3 8 16 17 15 2 7 20 21 11 10 6 18 1 5
ws: 2 ws: 1 ws: 2 ws: 2 ; total: 7




done:
	o6c4c, has 2cdcs:
		а я не хочу глянуть на связь с oriented вершинами?

		но на уровне переделки в 2 5cdcs
		и типа, они не должны никогда совпадать с вершинами
		которые встречаются в трёх циклах 3 раза
			(вершина может встретиться 1, 2 или 3 раза)

	не, даже на графе петерсена ломается
	чё-т не сообразил
	надо идею модифицировать как-то


==============================
==============================

todo:
	закодить достраивание до 5cdc решения из 2-6cdc
		и проверить total == 0 на 26.05
		но даже если там не будет total == 0,
		я всё равно думаю, что это реально

	nz6 из o6c4c (в случаях, когда нет nz5):
		может ли быть так, что они редуцируются до nz5?
		типа что есть цепи, которые можно полностью уменьшить на 1,
			так, что мы избавимся от 5?
		но я пока что не знаю, как такое проверять

todo: поискать какую-нибудь чиселку на 6c4c решениях
	такую что
	если она чему-то равна
	то у нас найдётся o6c4c

	есть антипример такого:
		в неориентированных кейсах
		бывает нечётный s0 и при этом есть 2 cdcs
			odd_poor_full_cycles == 0 всё ещё

todo:
	6c4c, инвариант, has 2cdcs, степени двойки:
		1) проверить, что разложение в 2 6cdc, если существует,
			то в целом единственно,
			с точностью до перестановок совпадающих полностью poor цепей
			(для этого достаточно сопоставить дифф s0 - doubles и число решений
			второе является двойкой в степени первого)
		2) доказать!
		3) понять, что даёт это доказательство
		или построение, то есть
			3.1) понять механику этого разбиения
			типа
			говорю
			допустим вот эта цепь идёт в первое из 6cdc
			судя по всему неважно что там - poor или rich рёбра
			но как-то мы умудряемся для остальных цепей сразу понять - в какую из половин их кинуть
			без перебора
			3.2) может быть вытащить что-нибудь отсюда для инварианта
			какую-нибудь чётность
			в этой логике
			раскидывания цепей по половинам


dominating circuit, 33pp, o6c4c:
	как я это буду кодить?
	может для начала просто восстановить то, что у меня было?
	но там я использовал armadillo
	для решения линейной системы уравнений
	перебираю nz5 и решение o6c4c
		получаю веса, нормирую до суммы = 0 (точно?)
	и дальше выясняется, что oriented вершины сидят на цикле
	и что веса специфические

	забавно, кстати
	по идее у меня на перебор есть оценка сверху
	хоть и большая

todo:
	winding number
	нужно пересчитать с учётом того,
	что весь набор цепей может совпасть


todo:
	могу попробовать такое:
	взять has 2cdcs
	взять решение, где три раза покрытые вершины не являются oriented
	и проверить:
		могу ли я собрать из этого o6c4c - nz5, с весами
		(-1, -1, 0, 0, 1, 1)
		или
		(-2, -1, 0, 0, 1, 2)


> 18g2 (у него вообще нет nz5 решений из o6c4c)!
у 18g1 значит есть
это я к тому, что вроде у обоих у них нету 2cdcs из o6c4c


пытаюсь доказать, что
#or_verts=0 => в каждом паросочетании чётное число rich рёбер
	хотел предположить, что
	допустим в графе все рёбра rich
	но это проблема, потому что
		происходит подмена понятий
		и теперь нужно доказать, что
		число вершин делится на 4

пытаюсь доказать, что
#or_verts != 1
	допустим у нас есть 1 oriented вершина
	тогда все 3 ребра рядом с ней - rich
	могу я вытащить противоречие?

	что, если в графе все рёбра rich?
	можно ли что-то по-простому тут доказать?

ладно, может такой вопрос:
	возьмём пару соседних рёбер
	правда ли, что если они соединены через ориентируемую вершину
	и если они соединены через неориентируемую вершину - то где-то заметна разница?



есть идея
взять 6c4c
а на цепи накидать ориентации, но произвольно
и подсчитать все возможные типы вершин
их 6 или 7 вариантов, насколько я понял
2 классических, 4 неклассических,
	и вот один из неклассических может быть ещё дополнительно различим
	в зависимости от направлений
и посмотреть - сохраняется чего или нет
я им даже названия дал
01, 02, 21, 22, 41, 42, 42'
идея такая
берём 6c4c и произвольную ориентацию
пусть в нём есть poor рёбра
берём poor ребро
возможно переориентируем некоторые из циклов,
	чтоб можно было сократить это ребро
	с сохранением ориентаций циклов
и смотрим, как меняются количества вершин от этого
и в конце надо понять, что делать с графом, где все рёбра rich



может начать печатать статью?


todo (only rich edges):
	во всех примерах parity == 1 (до 30.05g307)
	в том числе s0 всегда чётный
	(потому что так случается, что число вершин не делится на 4
	s1 нечётный
	s2 равен 0)


мне кажется, что
parity должно исправиться каким-то твистом
типа - посчитать - сколько цепей с нечётным числом poor компонент
18.05g2: another 6c4c: profile: rrrrppprprprpprrrprrrrrrrrr; s0= 13; s1= 19; s2= 0; par: 0; odds: 0; comps: 2 3; circuit lens: l0 (5 5 ) l1 (5 5 ) l2 (5 5 ) l3 (5 0 5 ) l4 (5 5 ) l5 (5 5 ); has 2 cdcs with 1;
хотя вот довольно безобидно
> has 2 cdcs
> par = 0
чё?
это же фейл
точнее даже
это супер-интересно
потому что я не видел такого для o6c4c

КАК Я ЭТО ПРОПУСТИЛ ВООБЩЕ
надо изучить

я ведь знал на самом деле об этом
но не размышлял

в принципе я даже вижу почему
надо s0 по-другому считать
"длина" - это надо poor считать за умножение на -1, а rich - за прибавление или вычитание к счётчику
надо выкинуть цепи, у которых "длина" равна 0
теперь для has 2cdcs:
	на 18.05, 20.05 всё ок!
	на 22.05 есть пример g4
	g4: another 6c4c: profile: rrrrrrpprpprrrrpprrrprrprrrrrrrpr; s0= 15; s1= 24; s2= 3; par: 0 vs 0; odds: 0; comps: 3 1; circuit lens: l0 (5 5 6 ) l1 (5 11 ) l2 (1 5 ) l3 (5 1 ) l4 (1 0 5 ) l5 (5 0 1 ); has 2 cdcs with 1;
но!
если выкинуть цепи, "длина" которых 11
	то снова ок, на 22.05
	но тут правда всего 1 пример, непоказательно
на 24.05 такое выкидывание ломает g16
	g16: another 6c4c: profile: rrrrrrrrrrrrrprprrprprrrppppprprrppr; s0= 14; s1= 24; s2= 3; par: 1 vs 0; odds: 0; comps: 5 1; circuit lens: l0 (5 1 ) l1 (5 1 ) l2 (5 1 0 ) l3 (11 5 ) l4 (5 1 0 ) l5 (1 5 ); has 2 cdcs with 1;

	g16: another 6c4c: profile: rrrrrrrrrrrrrprprrprrpprpprrprprpprp; s0= 15; s1= 24; s2= 3; par: 0 vs 0; odds: 0; comps: 5 1; circuit lens: l0 (5 1 ) l1 (1 5 ) l2 (5 1 0 ) l3 (5 1 0 ) l4 (5 1 ) l5 (5 6 5 ); has 2 cdcs with 1;
если выкидывать 6, а не 11, то везде будет ок на 24.05
	и на 22.04 тоже


20.05g2: another 6c4c: profile: rprrrrrprrprrrrrrpprrrrprrrrrr; s0= 13; s1= 24; s2= 1; par: 0 vs 0; odds: 2; comps: 5 1; circuit lens: l0 (-1 5 ) l1 (3 3 ) l2 (-1 1 ) l3 (-1 5 ) l4 (3 -1 ) l5 (-1 5 -1 ); no 2 cdcs; NEW 6C4C with o6c4c
такой фикс всё равно не помогает с таким примером
(но внезапно лечит весь 18.05, даже no 2cdcs)


-1 -1 -1 -1 -1 -1
1
3 3 3
5 5 5

l0 (3 5 ) l1 (9 5 ) l2 (-1 5 ) l3 (5 5 ) l4 (-1 5 ) l5 (-1 -1 )
-1 -1 -1 -1
3
5 5 5 5 5 5
9



todo:
	circuit lens, где есть -1
	vs
	has 2cdcs
	на 18.05 нет -1 при has 2cdcs
	на 20.05 есть, всегда парами, по 4 слоя вида (-1 -1) (остальные 2 - (5 7))
		это всё g1
	на 22.05 нет -1 при has 2cdcs
	на 24.05 нет -1 при has 2cdcs


выкидывание 6 ломает 18.05g2 там, где no 2cdcs
g2: another 6c4c: profile: rrprrrrrrrrrrprprrrrrrprrrr; s0= 13; s1= 23; s2= 1; par: 1 vs 0; odds: 1; comps: 3 1; circuit lens: l0 (-1 -1 ) l1 (-1 5 ) l2 (5 6 5 ) l3 (-1 5 ) l4 (5 5 ) l5 (1 5 ); no 2 cdcs; NEW 6C4C with o6c4c

10.05
tmp  - 18.05
tmp2 - 20.05
tmp3 - 22.04
tmp4 - 24.05
has 2cdcs, выкидываю цепи "длины" 0 и 6, par == 1
	это уже полторы тысячи примеров
	1+6+96+572+955
tmp5 - 24.04
	1+6+96+572+6191
	это уже дохрена
tmp6 - 26.05
	1+6+96+572+6191+7952
	это уже 14к примеров

todo:
	подозреваю,
	что это какой-то маппинг
	не в граф Петерсена
	а в какой-то другой
	и там появляются цепи в 6 и 11
	надо придумать colouring, например

24.04g12: another 6c4c: profile: rrrprprprrprrrprrpprprprrprrrrrrpppp; s0= 16; s1= 22; s2= 3; par: 1 vs 0; odds: 0; comps: 6 3; circuit lens: l0 (5 -1 -1 ) l1 (5 1 ) l2 (5 0 1 ) l3 (1 5 ) l4 (5 0 1 ) l5 (1 0 5 ); has 2 cdcs with 1; NEW 6C4C with o6c4c
вот это уже интереснее
непонятно
о, пара (-1 -1)
её тоже придётся вычесть

todo:
	это ещё один маппинг,
	теперь правда с твистом

о, ещё пример
24.04g55: another 6c4c: profile: rrprrrprrrrrrrrprrrprrrrrrrrrrrrprrp; s0= 19; s1= 30; s2= 3; par: 0 vs 0; odds: 0; comps: 4 1; circuit lens: l0 (0 5 5 ) l1 (0 5 5 ) l2 (10 5 0 5 ) l3 (0 5 5 ) l4 (0 5 5 ) l5 (0 5 5 ); has 2 cdcs with 1;
цепь "длины" 10

24.05g36: another 6c4c: profile: prrrrprrrrrprrrrrrrprrrrrrrrrprrrrrr; s0= 18; s1= 31; s2= 0; par: 1 vs 1; odds: 0; comps: 5 1; circuit lens: l0 (5 5 0 ) l1 (5 5 0 ) l2 (10 5 5 ) l3 (0 5 5 ) l4 (0 5 5 ) l5 (5 10 5 ); has 2 cdcs with 1; NEW 6C4C with o6c4c



done:
	has 2cdcs, o6c4c
	правда ли, что все "длины" цепей дублируются?
	неправда

	24.04g67: another 6c4c: profile: pprprrprprrrrprrprrrrrrprrrrrrrrrppr; s0= 16; s1= 26; s2= 3; par: 1 vs 1; odds: 0; comps: 4 2; circuit lens: l0 (1 0 5 ) l1 (11 5 ) l2 (1 5 0 ) l3 (1 0 5 ) l4 (5 6 5 ) l5 (11 5 ); has 2 cdcs with 1; NEW 6C4C with o6c4c
	0 0 0
	1 1 1
	5 5 5 5 5 5 5
	6
	11 11


следующая цель 26.05
на данный момент
	выбрасываю 0, 6, 10
	и пары (-1, -1)

	всё ок!
вау




g2: another 6c4c: profile: rrprrrrrrrrrrprprrrrrrprrrr; s0= 13; s1= 23; s2= 1; par: 1 vs 0; odds: 1; comps: 3 1; circuit lens: l0 (-1 -1 ) l1 (-1 5 ) l2 (5 6 5 ) l3 (-1 5 ) l4 (5 5 ) l5 (1 5 ); no 2 cdcs; NEW 6C4C with o6c4c





так
а может это маппинги в более мелкие снарки?
20.05
g1: another 6c4c: profile: rrrrrrrrrrrrrppprpprprrprrrprp; s0= 12; s1= 21; s2= 0; par: 1 vs 1; odds: 0; comps: 5 2; circuit lens: l0 (-1 -1 ) l1 (7 5 ) l2 (-1 -1 ) l3 (7 5 ) l4 (-1 -1 ) l5 (-1 -1 ); has 2 cdcs with 1; NEW 6C4C with o6c4c
g1: another 6c4c: profile: prrrrrrrprrrrppprrrrprrprrrprp; s0= 12; s1= 21; s2= 0; par: 1 vs 1; odds: 0; comps: 3 2; circuit lens: l0 (5 5 ) l1 (5 5 ) l2 (5 5 ) l3 (5 5 ) l4 (5 5 ) l5 (5 5 ); has 2 cdcs with 1; NEW 6C4C with o6c4c
	а вот этот ещё и не петерсенов


то есть возможно есть ещё один граф на 10 вершинах
с циклами длины 5
может это граф GP(5, 1)?
	а не, у него есть циклы длины 4
22.05
g4: another 6c4c: profile: rrrrrrpprpprrrrpprrrprrprrrrrrrpr; s0= 12; s1= 24; s2= 3; par: 1 vs 1; odds: 0; comps: 3 1; circuit lens: l0 (5 1 ) l1 (5 1 ) l2 (5 1 ) l3 (5 1 ) l4 (1 5 ) l5 (1 5 ); has 2 cdcs with 1;



может попробовать глянуть это решение глазами?

может попробовать закодить визуализацию?
не, лениво

но интересно
вот я возьму это решение
poor рёбра выдают совпадающие вершины
=> значит я могу посчитать верхнюю грань на число оригинальных вершин


p-------p----ppp----p--p---p-p
012345678901234567890123456789
g1
0:  10(e0)
2:  11(e8)
5:  12(e13)
5:  16(e14)
6:  10(e15)
9:  11(e20)
12: 18(e23)
16: 19(e27)
18: 19(e29)
0 = 10 = 6
2 = 11 = 9
5 = 12 = 18 = 19 = 16
20-8 = 12
ага, так интересно
может это tietze snark mapping?
это странно
по идее ровно 12 вершин должно быть
да, для петерсенова графа не хватает двух poor рёбер
или не хватает того, что цепь 5-12-18-19-16-5 разбивает граф на 2 части


0:  10(e0)  4(e1) 14(e2)
1:  9(e3) 18(e4)  6(e5)
2:  15(e6)  4(e7) 11(e8)
3:  8(e9) 19(e10) 7(e11)
4:  0(e1) 2(e7) 5(e12)
5:  4(e12)  12(e13) 16(e14)
6:  1(e5) 10(e15) 7(e16)
7:  3(e11)  6(e16)  15(e17)
8:  3(e9) 14(e18) 9(e19)
9:  1(e3) 8(e19)  11(e20)
10: 0(e0) 6(e15)  13(e21)
11: 2(e8) 9(e20)  13(e22)
12: 5(e13)  18(e23) 13(e24)
13: 10(e21) 11(e22) 12(e24)
14: 0(e2) 8(e18)  17(e25)
15: 2(e6) 7(e17)  17(e26)
16: 5(e14)  19(e27) 17(e28)
17: 14(e25) 15(e26) 16(e28)
18: 1(e4) 12(e23) 19(e29)
19: 3(e10)  16(e27) 18(e29)
dominating circuit: 2 4 5 16 19 18 12 13 10 6 7 15 17 14 8 9 11 2

а блин
некубический граф получу
степени вершин 0, 2, 5 - 5, у остальных - 3
со всеми вершинами 0,2,5 соединены 2 вершины - 4 и 13
если выкинуть вершины 4 и 13 - то получится граф на 10 вершинах, кубический
и это (был эйнштейн) граф Петерсена



g1: another 6c4c: profile: rrrrrrrrrrrrrppprpprprrprrrprp; s0= 12; s1= 21; s2= 0; par: 1 vs 1; odds: 0; comps: 5 2; circuit lens: l0 (-1 -1 ) l1 (7 5 ) l2 (-1 -1 ) l3 (7 5 ) l4 (-1 -1 ) l5 (-1 -1 ); has 2 cdcs with 1; NEW 6C4C with o6c4c
-------------ppp-pp-p--p---p-p
012345678901234567890123456789

5:  12(e13)
5:  16(e14)
6:  10(e15)
7:  15(e17)
8:  14(e18)
9:  11(e20)
12: 18(e23)
16: 19(e27)
18: 19(e29)

5 = 12 = 18 = 19 = 16
6 = 10
7 = 15
8 = 14
9 = 11


12 вершин
степень 4 - 9, 6, 7, 8
степень 5 - 5
3,1, 17,13
любая пара подходит
хотя правильнее выбросить вторую пару
потому что смотри ниже
здесь тоже остаётся граф Петерсена

и это несмотря на -1 и циклы длины 7


такое ощущение, что останется ppdc
	только не ppdc, а pp4c скорее
	и даже наверно не perfect, потому что вершины, которые я выкинул - только они ломают цепи
а можно наверно взять 4 копии графа петерсена
посклеивать их друг с другом
	и это типа разные способы выбрасывать вот эти пары вершин
	(1,3 или 1,17 или 13,3 или 13,17)
layer: 0; vertices: 4 5 12 13 10 6 7 3 8 14 0 4 ; rich-poor len: -1
layer: 0; vertices: 9 11 2 15 17 16 19 18 1 9 ; rich-poor len: -1
layer: 1; vertices: 4 2 11 13 10 p 6 7 p 15 17 14 0 4 ; rich-poor len: 7
	а что здесь будет, если выбросить 13,17
	- 8 - 0 - 4 - 2 - 9 -
	- 6 - 7 -
	а если 1,3:
	4-2-9-13-6-7-17-8-0-4
	получается цикл длины 9
layer: 1; vertices: 9 8 3 19 16 5 12 18 1 9 ; rich-poor len: 5
9 - 8 - . - 5 - .
	это если выбросить пару вершин 1, 3
	а если выбросить 13,17!
	то получу просто цепь
	9-8-3-5-1-9
layer: 2; vertices: 10 13 12 18 19 3 8 14 0 10 ; rich-poor len: -1
layer: 2; vertices: 9 11 2 4 5 16 17 15 7 6 1 9 ; rich-poor len: -1
layer: 3; vertices: 10 13 11 9 8 14 17 15 2 4 0 10 ; rich-poor len: 7
layer: 3; vertices: 18 12 5 16 19 3 7 6 1 18 ; rich-poor len: 5
layer: 4; vertices: 10 6 1 18 19 16 17 14 0 10 ; rich-poor len: -1
layer: 4; vertices: 15 7 3 8 9 11 13 12 5 4 2 15 ; rich-poor len: -1
layer: 5; vertices: 10 6 1 9 8 14 17 16 5 4 0 10 ; rich-poor len: -1
layer: 5; vertices: 15 7 3 19 18 12 13 11 2 15 ; rich-poor len: -1







22.05g4
g4: another 6c4c: profile: rrrrrrpprpprrrrpprrrprrprrrrrrrpr; s0= 15; s1= 24; s2= 3; par: 0 vs 1; odds: 0; comps: 3 1; circuit lens: l0 (5 5 6 ) l1 (5 11 ) l2 (1 5 ) l3 (5 1 ) l4 (1 0 5 ) l5 (5 0 1 ); has 2 cdcs with 1; circuits:
layer: 0; vertices: 14 15 17 16 0 14 ; rich-poor len: 5
layer: 0; vertices: 5 4 13 12 10 6 1 5 ; rich-poor len: 5
layer: 0; vertices: 19 18 21 20 7 3 8 9 11 2 19 ; rich-poor len: 6
layer: 1; vertices: 12 13 17 16 0 12 ; rich-poor len: 5
layer: 1; vertices: 18 21 20 6 10 11 9 8 3 7 19 2 15 14 4 5 1 18 ; rich-poor len: 11
layer: 2; vertices: 12 10 11 9 21 18 1 6 20 7 19 2 15 14 0 12 ; rich-poor len: 1
layer: 2; vertices: 8 16 17 13 4 5 3 8 ; rich-poor len: 5
layer: 3; vertices: 14 4 5 3 8 16 0 14 ; rich-poor len: 5
layer: 3; vertices: 18 19 7 20 21 9 11 2 15 17 13 12 10 6 1 18 ; rich-poor len: 1
layer: 4; vertices: 12 10 11 2 19 18 21 9 8 16 0 12 ; rich-poor len: 1
layer: 4; vertices: 5 3 7 20 6 1 5 ; rich-poor len: 0
layer: 4; vertices: 14 15 17 13 4 14 ; rich-poor len: 5
layer: 5; vertices: 12 13 4 14 0 12 ; rich-poor len: 5
layer: 5; vertices: 18 19 7 3 5 1 18 ; rich-poor len: 0
layer: 5; vertices: 15 17 16 8 9 21 20 6 10 11 2 15 ; rich-poor len: 1

g4
Printing graph:
0:  12(e0)  14(e1)  16(e2)
1:  18(e3)  5(e4) 6(e5)
2:  19(e6)  15(e7)  11(e8)
3:  8(e9) 5(e10)  7(e11)
4:  14(e12) 13(e13) 5(e14)
5:  1(e4) 3(e10)  4(e14)
6:  1(e5) 10(e15) 20(e16)
7:  3(e11)  19(e17) 20(e18)
8:  3(e9) 16(e19) 9(e20)
9:  8(e20)  21(e21) 11(e22)
10: 6(e15)  12(e23) 11(e24)
11: 2(e8) 9(e22)  10(e24)
12: 0(e0) 10(e23) 13(e25)
13: 4(e13)  12(e25) 17(e26)
14: 0(e1) 4(e12)  15(e27)
15: 2(e7) 14(e27) 17(e28)
16: 0(e2) 8(e19)  17(e29)
17: 13(e26) 15(e28) 16(e29)
18: 1(e3) 21(e30) 19(e31)
19: 2(e6) 7(e17)  18(e31)
20: 6(e16)  7(e18)  21(e32)
21: 9(e21)  18(e30) 20(e32)
dominating circuit: 2 11 9 8 16 17 13 12 10 6 20 21 18 19 7 3 5 4 14 15 2


------pp-pp----pp---p--p-------p-
012345678901234567890123456789012


2:  19(e6)  15(e7)
3:  8(e9) 5(e10)
6:  10(e15) 20(e16)
8:  9(e20)
10: 12(e23)
18: 19(e31)
2 = 19 = 15 = 18
3 = 5 = 8 = 9
6 = 10 = 20 = 12


layer: 0; vertices: 19 18 21 20 7 3 8 9 11 2 19 ; rich-poor len: 6

layer: 1; vertices: 18 21 20 6 10 11 9 8 3 7 19 2 15 14 4 5 1 18 ; rich-poor len: 11


0:  6(e0)  14(e1)  16(e2)
1:  2(e3)  3(e4) 6(e5)
2:  11(e8)
3:  7(e11)
4:  14(e12) 13(e13) 3(e14)
3:  1(e4) 4(e14)
6:  1(e5)
7:  3(e11)  2(e17) 6(e18)
3:  16(e19)
3:  21(e21) 11(e22)
6:  11(e24)
11: 2(e8) 3(e22)  6(e24)
6: 0(e0) 13(e25)
13: 4(e13)  6(e25) 17(e26)
14: 0(e1) 4(e12)  2(e27)
2:  14(e27) 17(e28)
16: 0(e2) 3(e19)  17(e29)
17: 13(e26) 2(e28) 16(e29)
2: 1(e3) 21(e30)
2: 7(e17)
6: 7(e18)  21(e32)
21: 3(e21)  2(e30) 6(e32)


or=0
с точки зрения моей теории - это самые простые 6c4c решения
цель, понять, могу ли я вычислить как-то s1-s0 или (s1-s0)/2
	то есть понять - чему эта разница соответствует конструктивно в решении
	а возможно найти неравенство с этим числом
 n s0 s1
20 14 22
		10 11  1

22 12 24
		10  6  8
22 14 24
		 8 12  4
22 14 26
		11 11  4
		12 10  4
		10 12  4
22 14 28
		12 12  4

24 13 25
24 13 27
24 13 29

24 15 27
24 15 29
24 15 31

24 16 24
24 16 28

это я считал хорды в паросочетании

не, надо что-то другое смотреть



20 14 22:
	1,1,1,5,3,3,5,5
	-1 x 6
думал изучить "длины" цепей
	но это не должно чего-то дать, по идее

22 12 24: -1 x 4, -1 x 0
22 14 24: -1 x 8, -1 x 4
22 14 26: -1 x 4, -1 x 0
22 14 28: -1 x 0


надо заценить решения с t1=0
ощущение, что там тоже совпадают чётности числа rich рёбер и числа цепей
не, неправда
24.05g1: new o6c4c: or: 03; t1+t3: 09; s0: 13; s1: 25; s2: 1; PAR: 1 (1); t1: 0; opc2f: 1; op2f: 1; orverts: 14 15 19 ; mod5: 0; mod6: 1;  nz5: 0; nz6: 1;
даже так


может надо посчитать число хорд и число цепей в каждом слое?
не, бывает 2 цепи и 9 антихорд, бывает 3 цепи и 9 антихорд в 20.05g5

интересно кстати, что до 24.05 где or = 0
	nz5: 0, mod5: 0, nz6: 1, mod6: 1
	а не, бывает ещё на 22.05
		nz5: 1, mod5: 1, nz6: 1, mod6: 1
	(хотя надо помнить, что nz5 и nz6 немного некорректны; но в данном случае вроде непроблема)



классная идея пришла в голову, вроде как
надо глянуть o6c4c,
которые можно разбить на пары слоёв,
которые в сумме не дадут вершин с потоком 0-2-2
	то есть такая ослабленная версия отсутствия oriented вершин
	(по-моему такой ослабленный вариант автоматом включает в себя
	случай or=2, типа
	a,b,c,d,e,f
	ab,cd,ef
	ad,ce,bf
	=> ac,be,df подойдёт)

можно по-быстрому проверить пример, который выше
24.05g1: new o6c4c: or: 03; t1+t3: 09; s0: 13; s1: 25; s2: 1; PAR: 1 (1); t1: 0; opc2f: 1; op2f: 1; orverts: 14 15 19 ; mod5: 0; mod6: 1;  nz5: 0; nz6: 1;

layer: 0; vertices: 22 23 9 8 0 22
layer: 0; vertices: 16 1 6 15 7 2 11 10 18 19 17 14 13 12 4 20 21 3 5 16
layer: 1; vertices: 22 0 8 21 3 7 2 20 4 5 16 19 18 10 11 23 9 13 12 22
layer: 1; vertices: 14 17 15 6 1 14
layer: 2; vertices: 10 11 2 20 21 8 0 10
layer: 2; vertices: 16 19 18 6 1 16
layer: 2; vertices: 5 3 7 15 17 14 13 9 23 22 12 4 5
layer: 3; vertices: 10 0 8 9 13 14 1 6 18 10
layer: 3; vertices: 7 15 17 19 16 5 3 21 20 4 12 22 23 11 2 7
layer: 4; vertices: 10 18 6 15 7 3 5 4 12 13 9 8 21 20 2 11 23 22 0 10
layer: 4; vertices: 14 17 19 16 1 14
layer: 5; vertices: 10 0 22 12 13 14 1 16 5 4 20 2 7 3 21 8 9 23 11 10
layer: 5; vertices: 18 19 17 15 6 18

forbid:
0-2, 1-4, 3-5
0-4, 1-5, 2-3
0-5, 1-2, 3-4

try:
0-1, 2-3, 4-5
хм, ну ладно, поломал идею
хотя постой, здесь же хороший parity




вот плохой parity
g2: new o6c4c: or: 03; t1+t3: 09; s0: 12; s1: 25; s2: 1; PAR: 0 (0); t1: 0; opc2f: 2; op2f: 1; orverts: 1 17 22 ; mod5: 0; mod6: 1;  nz5: 0; nz6: 1;
layer: 0; vertices: 22 4 5 3 23 7 2 18 21 20 0 22
layer: 0; vertices: 9 1 6 10 14 15 12 13 11 17 16 8 19 9

layer: 1; vertices: 14 0 22 4 2 7 23 3 5 12 13 10 6 1 15 14
layer: 1; vertices: 16 20 21 18 17 11 9 19 8 16

layer: 2; vertices: 22 0 20 16 17 18 21 19 8 3 23 22
layer: 2; vertices: 9 1 6 7 2 4 5 12 15 14 10 13 11 9
layer: 3; vertices: 14 15 1 9 11 17 16 20 0 14
layer: 3; vertices: 4 22 23 7 6 10 13 12 5 3 8 19 21 18 2 4
layer: 4; vertices: 14 0 20 21 19 9 11 13 10 14
layer: 4; vertices: 15 12 5 4 22 23 3 8 16 17 18 2 7 6 1 15
layer: 5; vertices: 14 10 6 7 23 22 0 14
layer: 5; vertices: 9 19 21 20 16 8 3 5 4 2 18 17 11 13 12 15 1 9

forbid:
0-2, 1-4, 3-5
0-3, 1-5, 2-4
0-1, 2-5, 3-4

try:
ничего не подошло
хм, прикольно
0-4, 1-2, oops
0-4, 1-3, oops
0-4, oops
0-5, 1-2, oops
0-5, 1-3, oops
0-5, oops
oops



g5: new o6c4c: or: 03; t1+t3: 09; s0: 15; s1: 28; s2: 1; PAR: 0 (0); t1: 0; opc2f: 2; op2f: 2; orverts: 1 8 11 ; mod5: 1; mod6: 1;  nz5: 1; nz6: 1;
layer: 0; vertices: 14 15 17 16 0 14
layer: 0; vertices: 5 1 20 6 10 12 13 4 5
layer: 0; vertices: 7 19 18 22 23 21 3 8 9 11 2 7

layer: 1; vertices: 14 0 16 8 3 21 19 18 1 5 4 14
layer: 1; vertices: 7 2 15 17 13 12 10 11 9 22 23 20 6 7

layer: 2; vertices: 12 13 17 15 14 4 5 3 21 23 22 9 8 16 0 12
layer: 2; vertices: 18 19 7 2 11 10 6 20 1 18
layer: 3; vertices: 12 10 6 7 19 21 23 20 1 18 22 9 11 2 15 14 0 12
layer: 3; vertices: 8 3 5 4 13 17 16 8
layer: 4; vertices: 12 0 16 17 13 4 14 15 2 11 10 12
layer: 4; vertices: 18 1 5 3 8 9 22 18
layer: 4; vertices: 20 23 21 19 7 6 20
layer: 5; vertices: 12 0 14 4 13 12
layer: 5; vertices: 5 1 20 23 22 18 19 21 3 5
layer: 5; vertices: 7 6 10 11 9 8 16 17 15 2 7

forbid:
0-5, 1-4, 2-3
0-4, 1-3, 2-5
0-3, 1-5, 2-4

try:
0-1, oops
0-2, oops


g3: new o6c4c: or: 03; t1+t3: 09; s0: 16; s1: 18; s2: 1; PAR: 1 (1); t1: 0; opc2f: 0; op2f: 2; orverts: 1 10 11 ; SEAL; mod5: 0; mod6: 1;  nz5: 0; nz6: 1;
layer: 0; vertices: 16 19 17 8 20 21 18 0 16
layer: 0; vertices: 9 1 22 23 11 9
layer: 0; vertices: 7 2 4 14 15 3 5 12 13 10 6 7

layer: 1; vertices: 16 0 18 21 20 8 17 19 16
layer: 1; vertices: 9 11 2 7 3 15 14 4 5 12 1 9
layer: 1; vertices: 10 6 22 23 13 10

layer: 2; vertices: 16 0 8 20 9 1 22 6 10 16
layer: 2; vertices: 7 2 11 23 13 12 5 4 14 18 21 19 17 15 3 7

layer: 3; vertices: 16 10 13 23 11 9 20 8 0 16
layer: 3; vertices: 12 5 3 15 17 19 21 18 14 4 2 7 6 22 1 12
layer: 4; vertices: 18 0 8 17 15 14 18
layer: 4; vertices: 9 20 21 19 16 10 13 12 1 9
layer: 4; vertices: 4 2 11 23 22 6 7 3 5 4
layer: 5; vertices: 18 14 15 17 8 0 18
layer: 5; vertices: 12 13 23 22 1 12
layer: 5; vertices: 4 5 3 7 6 10 16 19 21 20 9 11 2 4

forbid:
0-2, 1-4, 3-5
0-1, 2-5, 3-4
0-3, 1-5, 2-4

try:
0-4, 1-2, 3-5, oops
0-4, 1-3, 2-5, oops
0-5, 1-2, 3-4, oops
0-5, 1-3, 2-4, oops
вот пример, где parity == 1, а разбить на 3 пары всё равно нельзя

0-a, 1-b, 2-c
0-b, 1-2, a-c
тогда
0-c, 1-a, 2-b
и всё ок

как это закодить?
	собираю по каждому слою triples, их V штук
	проверяю слои с совпадающими triples и получаю пары несовместимых слоёв

0-1, 2-3, 4-5
0-1, 2-4, 3-5
0-1, 2-5, 3-4
* 5
15 вариантов
ну или перебираю 3 пары из возможных и ищу такую тройку, где есть все 6 слоёв




g1: new o6c4c: or: 06; t1+t3: 17; s0: 14; s1: 30; s2: 1; PAR: 1 (1); t1: 1; opc2f: 2; op2f: 2; orverts: 1 2 3 8 9 19 ; mod5: 0; mod6: 1;  nz5: 0; nz6: 1; trip-partition

layer: 0; vertices: 22 12 13 9 23 11 10 18 6 15 7 2 20 4 5 3 21 8 0 22
layer: 0; vertices: 14 17 19 16 1 14

layer: 1; vertices: 10 0 22 23 9 8 21 20 2 11 10
layer: 1; vertices: 16 19 18 6 1 16
layer: 1; vertices: 5 4 12 13 14 17 15 7 3 5

layer: 2; vertices: 10 11 2 7 3 5 16 1 14 13 9 23 22 12 4 20 21 8 0 10
layer: 2; vertices: 18 19 17 15 6 18
layer: 3; vertices: 10 0 8 9 13 14 1 6 18 10
layer: 3; vertices: 7 15 17 19 16 5 3 21 20 4 12 22 23 11 2 7
layer: 4; vertices: 22 0 8 9 13 12 4 5 16 19 18 10 11 23 22
layer: 4; vertices: 14 1 6 15 17 14
layer: 4; vertices: 7 2 20 21 3 7
layer: 5; vertices: 10 18 19 17 14 13 12 22 0 10
layer: 5; vertices: 16 5 4 20 2 11 23 9 8 21 3 7 15 6 1 16





g1: new o6c4c: or: 04; t1+t3: 12; s0: 15; s1: 31; s2: 2; PAR: 0 (0); t1: 0; opc2f: 1; op2f: 2; orverts: 3 4 14 18 ; mod5: 0; mod6: 1;  nz5: 0; nz6: 1; pair-partition; WATAFAK

layer: 0; vertices: 22 23 9 8 0 22
layer: 0; vertices: 16 1 6 15 7 3 21 20 2 11 10 18 19 17 14 13 12 4 5 16
layer: 1; vertices: 22 0 8 21 3 5 16 19 17 15 7 2 20 4 12 22
layer: 1; vertices: 14 1 6 18 10 11 23 9 13 14

layer: 2; vertices: 10 11 2 20 21 8 0 10
layer: 2; vertices: 16 19 18 6 1 16
layer: 2; vertices: 5 3 7 15 17 14 13 9 23 22 12 4 5
layer: 4; vertices: 10 0 8 9 13 12 22 23 11 2 7 15 6 18 10
layer: 4; vertices: 14 17 19 16 1 14
layer: 4; vertices: 21 3 5 4 20 21

layer: 3; vertices: 10 18 19 16 5 3 7 2 11 23 22 0 10
layer: 3; vertices: 14 17 15 6 1 14
layer: 3; vertices: 12 13 9 8 21 20 4 12
layer: 5; vertices: 10 0 22 12 13 14 1 16 5 4 20 2 7 3 21 8 9 23 11 10
layer: 5; vertices: 18 6 15 17 19 18

forbid:
0-5, 1-4, 2-3
0-2, 1-3, 4-5
0-2, 1-5, 3-4
0-3, 1-4, 2-5
try:
0-1, 2-4, 3-5
0-4, 1-2, 3-5
прикол


поломал идею ослабления oriented вершин
красивый пример


какой ещё подход попробовать?
	можно попробовать глянуть на все примеры с s2 = 3
	24.05



так, интересно
я тут размышлял про то, как склеивать цепи из 6c4c
если рёбра rich - то там ровно 1 способ
если poor - то надо выбрать 1 из 2, пока не знаю как
так вот - если решение распадается на 2 6cdc - то такая склейка тоже распадается
	потому что она ровно про это и будет
	точнее я глянул граф петерсена
	там все рёбра rich
в общем,
	про 6cdc понятно, почему такое разложение единственно

теперь 2 вопроса:
	- что можно вытащить из o6c4c?
		а именно
		почему число цепей чётно?
	- что получается, если разложения такого нет? склейку можно осуществить?
		можно
		хорошо
		что из склейки можно вытащить?
		а именно
		хочу вытащить характеристику эйлера
		как её посчитать?
			ну по идее в лоб
			число цепей - число рёбер * 2 + число вершин * 2

12 - 30 + 20 = 2 для петерсена = две проективные поверхности
а вообще
s0 - 2e + 2v = s0 - v
если есть o6c4c и разложение в 2 6cdc, то типа получится чётная характеристика



для o6c4c можно придумать альтернативное деление на t1, t2, t3, t4
	просто другая семантика, сами значения останутся те же
	раньше я делил на uu, uo, oo
	а тут надо разбить 4 проходки по ребру на 2 пары
		и посмотреть - сонаправленны рёбра там или нет
t1		-1- было:  ребро poor, обе вершины oriented
			стало: совпадающие тройки сонаправленны

t2		-2- было:  ребро poor, обе вершины unoriented
			стало: совпадающие тройки разнонаправленны

t3		-3- было:  ребро rich, одна вершина oriented, одна unoriented
			стало: противоположности разнонаправленны

t4		-4- было:  ребро rich, обе вершины unoriented
			стало: противоположности сонаправленны

\       /
 |  и  |  -  противоположности
/       \

в каком-то смысле (t1 и t3) аналогичны, как и пара (t2 и t4)
а ещё можно отдельно uu: t2 + t4
да, забавно


done:
	можно вот что попробовать
	взять 6c4c
	глянуть эти разбиения на 2 6cdc
	и изучить o6cdc
	ориентируемы эти половины или нет
	и посмотреть на parity

	хотя постой
	если бы они оба были ориентируемы
	то я бы очевидно получил o6c4c

	хотя у меня ощущение, что
	оба 6cdc вообще всегда неориентируемы и я не получаю никакой информации тут

	резюме
	глянул 2 примера на 24.05, g1, g2
	в одном parity 0, в другом parity 1
	в обоих есть разложение в 2 6cdc
	в обоих все 6cdc неориентируемы

	подозреваю, что это вообще всегда так, но не проверил
	интересно было бы глянуть, можно ли ориентировать 6cdc так, что
	дважды ориентированный цикл сидит в соседнем 6cdc

24.05
g1: another 6c4c: profile: rrrprppprppprpprprrrrrrrrrrrprppprpr; s0= 13; s1= 21; s2= 0; par: 0 vs 1; odds: 0; comps: 3 4; circuit lens: l0 (5 5 ) l1 (5 5 ) l2 (5 5 ) l3 (5 0 5 ) l4 (5 5 ) l5 (5 5 ); has 2 cdcs with 1; circuits:


> layer: 0; vertices: 22 23 9 8 0 22 ; rich-poor len: 5
> layer: 1; vertices: 14 13 9 23 11 10 18 6 1 14 ; rich-poor len: 5
> layer: 2; vertices: 14 1 16 5 3 21 8 9 13 12 4 20 2 7 15 6 18 19 17 14 ; rich-poor len: 5
> layer: 3; vertices: 10 0 8 21 20 4 5 3 7 2 11 10 ; rich-poor len: 5
> layer: 4; vertices: 10 18 19 16 1 6 15 17 14 13 12 22 0 10 ; rich-poor len: 5
> layer: 5; vertices: 20 2 11 23 22 12 4 5 16 19 17 15 7 3 21 20; rich-poor len: 5
неориентируемо (17-14-13 два раза)

> layer: 0; vertices: 16 5 4 12 13 14 17 19 18 10 11 2 20 21 3 7 15 6 1 16 ; rich-poor len: 5
< layer: 1; vertices: 22 12 4 20 2 7 15 17 19 16 5 3 21 8 0 22 ; rich-poor len: 5
layer: 2; vertices: 10 11 23 22 0 10 ; rich-poor len: 5
< layer: 3; vertices: 14 17 15 6 18 19 16 1 14 ; rich-poor len: 0
> layer: 3; vertices: 13 12 22 23 9 13 ; rich-poor len: 5
< layer: 4; vertices: 7 3 5 4 20 21 8 9 23 11 2 7 ; rich-poor len: 5
> layer: 5; vertices: 10 18 6 1 14 13 9 8 0 10 ; rich-poor len: 5
неориентируемо





g2: another 6c4c: profile: rrrrrrprrrrppprrppprpprrrrrrrrpprppr; s0= 14; s1= 23; s2= 0; par: 1 vs 1; odds: 0; comps: 4 2; circuit lens: l0 (5 0 5 ) l1 (5 5 0 ) l2 (5 5 ) l3 (5 5 ) l4 (5 5 ) l5 (5 5 ); has 2 cdcs with 1; circuits:

> layer: 0; vertices: 14 15 12 13 10 14 ; rich-poor len: 5
< layer: 1; vertices: 22 4 5 12 13 11 9 19 21 20 0 22 ; rich-poor len: 5
< layer: 2; vertices: 9 19 8 3 23 7 2 18 21 20 16 17 11 13 10 6 1 9 ; rich-poor len: 5
< layer: 3; vertices: 14 15 1 9 11 17 18 21 19 8 16 20 0 14 ; rich-poor len: 5
< layer: 4; vertices: 15 12 5 3 8 16 17 18 2 4 22 23 7 6 1 15 ; rich-poor len: 5
> layer: 5; vertices: 14 10 6 7 2 4 5 3 23 22 0 14 ; rich-poor len: 5
неориентируемо
...-9-19-8-16-17-...

< layer: 0; vertices: 22 23 7 6 1 9 11 17 16 20 0 22 ; rich-poor len: 5
> layer: 0; vertices: 4 5 3 8 19 21 18 2 4 ; rich-poor len: 0
layer: 1; vertices: 15 14 10 6 1 15 ; rich-poor len: 5
< layer: 1; vertices: 7 23 3 8 16 17 18 2 7 ; rich-poor len: 0
layer: 2; vertices: 14 15 12 5 4 22 0 14 ; rich-poor len: 5
layer: 3; vertices: 7 6 10 13 12 5 3 23 22 4 2 7 ; rich-poor len: 5
>< layer: 4; vertices: 14 10 13 11 9 19 21 20 0 14 ; rich-poor len: 5
> layer: 5; vertices: 9 19 8 16 20 21 18 17 11 13 12 15 1 9 ; rich-poor len: 5
неориентируемо



done:
	интересно было бы глянуть, можно ли ориентировать 6cdc так, что
	дважды ориентированный цикл сидит в соседнем 6cdc

	для петерсена это прокатывает

	можно попробовать это в общем сформулировать как:
	- можно ли выбрать любой слой
	в нём - perfect matching
	и попросить конкретно все рёбра этого perfect matching'а ориентировать правильно,
	одну часть быть дважды ориентированной во втором 6cdc,
	а вторую часть быть дважды ориентированной в первом 6cdc?

	резюме:
	попробовал 2 разложения в пару 6cdc
	в одном нет o6c4c, двойная ориентация провалилась наполовину
	в другом есть o6c4c, двойная ориентация провалилась наполовину
	не знаю, что тут дальше изучать
	

g16: another 6c4c: profile: rrrrrrrrrrrrrprprrprprrrppppprprrppr; s0= 14; s1= 24; s2= 3; par: 1 vs 1; odds: 0; comps: 5 1; circuit lens: l0 (5 1 ) l1 (5 1 ) l2 (5 1 0 ) l3 (11 5 ) l4 (5 1 0 ) l5 (1 5 ); has 2 cdcs with 1; circuits:

layer: 0; vertices: 11 20 21 23 18 13 12 17 10 22 15 19 16 6 7 3 5 14 1 11 ; rich-poor len: 1
> layer: 1; vertices: 4 5 3 8 0 4 ; rich-poor len: 5
< layer: 2; vertices: 11 9 2 4 5 14 15 22 23 18 1 11 ; rich-poor len: 1
< layer: 2; vertices: 17 16 19 21 20 10 17 ; rich-poor len: 0
< layer: 3; vertices: 7 3 8 9 2 7 ; rich-poor len: 5
< layer: 4; vertices: 12 13 6 7 2 4 0 12 ; rich-poor len: 5
> layer: 5; vertices: 12 17 16 6 13 18 1 14 15 19 21 23 22 10 20 11 9 8 0 12 ; rich-poor len: 1
4-2-9-8-0-4
здесь можно дважды ориентировать

> layer: 0; vertices: 4 2 9 8 0 4 ; rich-poor len: 5
< layer: 2; vertices: 12 13 6 7 3 8 0 12 ; rich-poor len: 5
> layer: 1; vertices: 11 9 2 7 6 16 17 12 13 18 23 22 10 20 21 19 15 14 1 11 ; rich-poor len: 1
> layer: 3; vertices: 12 17 10 20 11 1 18 13 6 16 19 21 23 22 15 14 5 4 0 12 ; rich-poor len: 11
layer: 4; vertices: 17 16 19 15 22 10 17 ; rich-poor len: 0
> layer: 4; vertices: 14 5 3 8 9 11 20 21 23 18 1 14 ; rich-poor len: 1
< layer: 5; vertices: 7 3 5 4 2 7 ; rich-poor len: 5
неориентируемо
11-20-21-
не, не могу ориентировать так, чтоб
цикл
11 20 21 23 18 13 12 17 10 22 15 19 16 6 7 3 5 14 1 11
был ориентирован дважды

здесь правда нет o6c4c



а вот здесь есть o6c4c
g12: another 6c4c: profile: rrrpprpprpprrrrprrrrrprprrrrrrrrrrrr; s0= 18; s1= 27; s2= 0; par: 1 vs 1; odds: 0; comps: 3 3; circuit lens: l0 (5 4 5 ) l1 (5 4 5 ) l2 (5 5 4 ) l3 (4 5 5 ) l4 (4 5 5 ) l5 (5 4 5 ); has 2 cdcs with 1; circuits:

layer: 0; vertices: 14 15 17 16 0 14 ; rich-poor len: 5
layer: 0; vertices: 21 18 19 7 6 21 ; rich-poor len: 5
< layer: 1; vertices: 9 11 10 12 13 17 15 2 22 19 18 1 9 ; rich-poor len: 4
layer: 2; vertices: 12 13 4 14 0 12 ; rich-poor len: 5
> layer: 2; vertices: 5 3 20 23 21 18 1 5 ; rich-poor len: 5
< layer: 3; vertices: 19 22 23 20 7 19 ; rich-poor len: 5
< layer: 3; vertices: 8 16 17 13 4 5 3 8 ; rich-poor len: 5
> layer: 4; vertices: 12 10 6 21 23 22 2 11 9 8 16 0 12 ; rich-poor len: 4
> layer: 5; vertices: 9 8 3 20 7 6 10 11 2 15 14 4 5 1 9 ; rich-poor len: 4
9-8-3-20-23-22-2-15-...
а тут нельзя дважды ориентировать, чтоб получить цикл
9 8 3 20 23 22 2 11 10 12 13 4 5 1 9

layer: 0; vertices: 9 8 3 20 23 22 2 11 10 12 13 4 5 1 9 ; rich-poor len: 4
> layer: 1; vertices: 14 4 5 3 8 16 0 14 ; rich-poor len: 5
< layer: 1; vertices: 21 23 20 7 6 21 ; rich-poor len: 5
< layer: 2; vertices: 22 19 7 6 10 11 9 8 16 17 15 2 22 ; rich-poor len: 4
< layer: 3; vertices: 12 10 6 21 18 1 9 11 2 15 14 0 12 ; rich-poor len: 4
> layer: 4; vertices: 14 15 17 13 4 14 ; rich-poor len: 5
> layer: 4; vertices: 5 3 20 7 19 18 1 5 ; rich-poor len: 5
> layer: 5; vertices: 12 13 17 16 0 12 ; rich-poor len: 5
> layer: 5; vertices: 21 23 22 19 18 21 ; rich-poor len: 5
дважды ориентировано:
14-15-17-16-0-14
21-6-7-19-18-21
найс, тут можно





done:
	в разбиении на 2-6cdc
	бывает, что берёшь 3 слоя - а остальные немного меняешь
	и получаешь 5cdc
	так вот
	там бывают вершины, которые покрыты полностью в этих трёх слоях
	правда ли, что они не пересекаются с oriented вершинами?

	неправда (но я забыл это законспектировать; теперь законспектировал)




===================================
===================================

давай я ещё раз выпишу все гипотезы:

2 6cdcs, 6c4c:
0	- total_poor_comps > 1
	не знаю насколько это важно, но пускай тоже будет
i	- odd_poor_full_cycles == 0
	(или слабее - s1 и s2 разной чётности; parity и s0 разной чётности)
ii	- s2 или 0, или 3
	(про s0 ничего сказать нельзя, он бывает чётным и нечётным)
	done: а что насчёт odd_poor_comps_full_cycles?
		22.05: 0, 1, 2, 3
		то есть ничего
		и в o6c4c тоже ничего

2 6cdcs, o6c4c (в дополнение к 6c4c):
iii	- s0 чётно
	(соответственно parity = 1)
iv	- or == s1 (mod 2)
	можно переформулировать - t4 чётно (потому что t3 совпадает по чётности с or и s1-t3=t4)

	факт:
	смотрим на эти 6cdc решения
	и посмотрим на исходные ориентации рёбер
	в каждом из 6cdc получится цикл, который дважды ориентирован в одну сторону
	(этот цикл один и тот же)
	можно посчитать в нём rich рёбра - они составляют подмножество t4
	(потому что в одну половину попадают противоположности
	а тут они ещё и сонаправленны)
	так вот - легко понять, что это в точности все рёбра из t4
	(при этом на цикле ещё могут быть вполне poor рёбра, и там ничего не понятно)

v
- невозможность or = 1

vi
- невозможность 16 rich рёбер

vii
- не бывает меньше 15 rich рёбер (и ровно 15, если граф не Петерсен)

or = 0:
viii- s2 = 3
ix	- parity = 1
	(или слабее - s0 совпадает по чётности с s1)

t1+t3 <= 8:
x	- parity == 1

xi
- odd_poor_comps_full_cycles делится на 2
	poor, comps, full_cycle - todo
	rich, comps, full_cycle - todo
	poor, comps, matching - todo
	rich, comps, matching - false!
	на самом деле такое надо доказать

если o6c4c, есть nz-mod5 и нет nz-mod6, то
xii	- or > 2
xiii- s0 чётно
 	на 26.05 - 3073 примера - так что буду считать эти гипотезы legit

total_poor_comps == 1:
xiv	- s0 и par разной чётности
xv	- если есть o6c4c, то s0 чётный
	примеров довольно мало, на 26.05 - 199

- todo: (oo+uu) % 2 == 1
	чё

- что-то про совпадение 5cdc из разных petersen colourings


===================================
===================================

- самое мистическое для меня - это 
odd_poor_comps_full_cycles
и наверняка это тоже что-то очень простое
	но я не понимаю пока что
	как это разбиение на компоненты такое чётное
	нужно наверно по индукции доказывать
	если нет poor рёбер - очевидно (opc2f = 0)
	если ребро такое одно - тоже очевидно (opc2f = 2)
	если рёбер 2 и они несвязны - то очевидно,
	если связны: в 2 слоях чётно, в 4 нечётно
	если 3 связных ребра (остальные случаи аддитивны по индукции)
	и вообще удобно, кстати, достаточно просто понять про k связных рёбер, почему с ними всё хорошо
	так вот, 3 связных ребра:
		- это или звезда (тогда opc2f = 0)
		- или путь в 3 ребра
			тогда смотрим - poor или rich среднее ребро
			получаем 2 варианта конфигураций для poor, 1 для rich
			во всех случаях всё ок
			хотя мы же знаем, что все 3 ребра poor
	4 связных ребра:
		- сложно
	но кажется неважно - это rich или poor рёбра
	как оказалось - ситуация гораздо интереснее, с этими компонентами

	хотя как посмотреть:
		кажется, что случаи poor, comps, full_cycle и poor, comps, matching
		доказать супер просто
		надо на самом деле глазами глянуть на примеры
		должно быть просто,
		потому что poor рёбра повторяют всё по 2 раза
		а тут просто кластеры poor рёбер
		и будут прям кластерами повторяться
		и всё
	а вот rich, comps, full_cycle сложнее
		но кажется, что как раз тут индукция прокатывает

done:
	а что про другие комбинации оdd poor/rich comps/просто full_cycle/matching можно сказать?
	всего 8 вариантов
	ну ладно, все не comps варианты очевидно верны

	poor, ., full_cycle - true
	rich, ., full_cycle - true
	poor, ., matching - true
	rich, ., matching - true
	
	poor, comps, full_cycle - todo
	rich, comps, full_cycle - todo
	poor, comps, matching - todo
	rich, comps, matching - false!

	как интересно
	проверил на 20.05, 22.05, 24.05


в случае has 2 cdcs, и для 6c4c, и для o6c4c:
	все 3 числа
	poor, comps, full_cycle
	rich, comps, full_cycle
	poor, comps, matching

	бывают 0, 1, 2, 3

в случае or == 0:
	нету rich, comps, full_cycle == 2
	для 22.05, 24.05
	но скорее всего появится, просто редкое событие
	да, на 26.05 появилось


done:
	total_poor_comps = 1
	правда ли, что parity == 1?
	20.05, 22.04, 24.05 - ок
	26.05 - ломается
	
	хотел такое сформулировать, но это всё неправда
	total_poor_comps == 1
	xiv	- parity == 1
	xv	- s0 чётно
	xvi	- s2 = 1 или s2 = 2
		(хотя примеров маловато)

	на 26.05:
		g13 : s0 = 13, s1 = 33, s2 = 0, par = 0, нет o6c4c
		g32 : s0 = 15, s1 = 28, s2 = 1, par = 0, нет o6c4c
		g79 : s0 = 13, s1 = 36, s2 = 3, par = 0, нет o6c4c
		g115: s0 = 15, s1 = 38, s2 = 1, par = 0, нет o6c4c
			4 решения
		g172: s0 = 17, s1 = 38, s2 = 1, par = 0, нет o6c4c
			8 решений
		g173: s0 = 15, s1 = 38, s2 = 1, par = 0, нет o6c4c
			6 решений
		g234: s0 = 17, s1 = 38, s2 = 1, par = 0, нет o6c4c
		g235: s0 = 17, s1 = 38, s2 = 1, par = 0, нет o6c4c
			3 решения
		g253: s0 = 17, s1 = 38, s2 = 1, par = 0, нет o6c4c
			4 решения
		g254: s0 = 17, s1 = 38, s2 = 1, par = 0, нет o6c4c
			4 решения
		g257: s0 = 21, s1 = 38, s2 = 1, par = 0, нет o6c4c
			2 решения

done:
	total_poor_comps = 1
	можно было бы попробовать тогда ограничиться
		только чётными s0,
		или решениями с o6c4c
	резюме
	поставил assert
	проверил до 26.05



- or = 0 => s2 = 3, parity = 1
	(или слабее - s0 совпадает по чётности с s1)
	была идея найти какой-то чётный дифф d, чтоб
	s1 - s0 = d

- разбиение в пару 6cdc выглядит очень богатым (содержательным)
	и поэтому перспективным в изучении



todo:
	надо ещё насчитать локальных статистик
	по вершинам, по рёбрам
	желательно для 6c4c, не o6c4c

	типа тех же rich_vertices_frequency


todo:
	o6c4c, has 2cdcs
	а можно ли как-то связать разложение и oriented вершины?
	друг с другом
	тут есть гипотеза, что or == s1 (mod 2)
	как-то rich рёбра связаны с числом oriented вершин

todo:
	можно ещё попробовать
	same profiles
	но в одном есть 2cdcs, а в другом нет

todo:
	как oriented вершины ассоциировать с rich рёбрами?
		через t3: чётность t3 и or совпадают

	как rich рёбра ассоциировать с цепями?
		todo: надо что-то придумать здесь типа t1,t2,t3,t4


t1		-1- было:  ребро poor, обе вершины oriented
			стало: совпадающие тройки сонаправленны

t2		-2- было:  ребро poor, обе вершины unoriented
			стало: совпадающие тройки разнонаправленны

t3		-3- было:  ребро rich, одна вершина oriented, одна unoriented
			стало: противоположности разнонаправленны

t4		-4- было:  ребро rich, обе вершины unoriented
			стало: противоположности сонаправленны

надо t3 и t4 глянуть для has 2cdcs
чётность t3 совпадает с or (легко доказать)
надо об этом помнить

тогда
переформулируем:
если есть 2cdcs, o6c4c, то
	t4 чётно

	если глянуть на ориентацию каждого из 6cdc
	то там есть дважды ориентированный цикл
	он совпадает в обеих частях
	если на нём есть rich ребро, то оно входит в t4
	да и наоборот тоже, если есть ребро в t4, то куда ему деваться

	а почему не все рёбра из t2?
	а, логично
	потому что у противоположных троек рёбер направления непонятно как соотносятся

всё ещё непонятно - почему t4 чётно? (и число цепей тоже)
	а ещё t4 как минимум 6 (наверно на .04 можно найти 4)
	но по-крайней мере есть "геометрический" образ
	s0 может быть меньше, чем t4 (на 26 вершинах)

todo:
	можно ли эти рёбра раскрасить в 2 цвета?
	а это интересно
	интересно, что из-за возможности разбиения в 2 6cdc - нет вершин с тремя рёбрами t4

интересно
todo:
	что из себя представляет подмножество рёбер t2+t4?
		в принципе это то же самое, что и описать множество oriented вершин
	в случае "есть 2cdcs, o6c4c" - это цикл + ещё какие-то рёбра из t2

todo:
	во
	новый вариант статистики
	не rich_unoriented_vertices_frequency
	а частоты по t1,t2,t3,t4
		(и понятно, например, что если #t1 > 0, то #t2=0 и #t4=0)
		(и наоборот)
	(3,0,0,0)
	(2,0,1,0)
	(1,0,2,0)
	(0,3,0,0)
	(0,2,1,0)
	(0,2,0,1)
	(0,1,2,0)
	(0,1,1,1)
	(0,1,0,2)
	(0,0,3,0)
	(0,0,2,1)
	(0,0,1,2)
	(0,0,0,3)
	13 вариантов

has 2cdcs ещё можно переформулировать как
	давайте покрасим цепи в 2 цвета так, чтоб
	если 2 цепи одного цвета, то у них нет совпадающей пары подряд идущих рёбер
	ничего нового, просто забавно

так
смотрим t4f
t4f[3] = 0
=> t4f[1] чётно
	какие рёбра соседние с одиночными t4?
	явно не t1
	остаются t2 и t3
	посчитаем сколько рёбер t2 (0, 1, 2)
	не бывает 0, всегда есть одно или 2 ребра t2
	это логично - потому что в дважды-ориентированный цикл
	входят все рёбра t4 + несколько рёбер t2

t4 = (t4f[1] + 2 * t4f[2] + 3 * t4f[3]) / 2

может посчитать - сколько t4 рёбер несёт каждая цепь?

хм
забавно, получается
если есть 2cdcs и o6c4c
и если взять все uu рёбра
то в этом наборе обязательно сидит цикл (дважды ориентированный)
интересно, как в других случаях происходит

ну кстати
можно залепить и здесь
todo:
	построить 33pp на этом цикле
	тогда получится, что все oriented вершины будут подмножеством ignored вершин

зато
вообще все рёбра рядом с oriented вершинами - все направлены в обе стороны

has 2cdcs, o6c4c
решил посчитать хорды и антихорды (по типам t1,t2,t3,t4)
	закономерностей не нашёл (в плане чётностей)


s3 = число цепей с чётным числом poor рёбер
s0 и s3 всегда совпадают по чётности

чётность t3 совпадает с or
	док-во: #or = (2#t1 + #t3) / 3
	3#or = 2#t1 + #t3
	#or = #t3 (mod 2)

как чётность числа цепей перенести на рёбра?
	прикол в том, что в ребре 2 вершины, чётко и понятно
	в цепи число рёбер варьируется

	а с другой стороны
	по модулю 2 нам интересно не число цепей, а число цепей чётной длины
	неплохо, но хочется большего

ну или может по индукции можно?
	берём has 2cdcs, o6c4c
	и пытаемся выкинуть какое-нибудь ребро с сохранение обоих свойств


вообще обычно по гипотезам:
	- or и s1 как-то бывают связны по чётности
	- s1 и s2 как-то бывают связны по чётности
	- s0 бывает чётным
	- при or=0 связаны s0 и s1, s2 зафиксирован

пускай
	t4 чётный
	s0 чётный
	par может быть 0?
	24.05
	g2: new o6c4c: or: 03; t1+t3: 09; s0: 12; s1: 25; s2: 1; PAR: 0 (0); t1: 0; t2: 11; t3: 9; t4: 16; opc2f: 2; o_op2f: 1; t4f: 5 7 11 1; c: 0 8 6 14; a: 0 14 12 18; o_comps: 5 1; o_morecomps: 2 3 1; mod5: 0; mod6: 1; orverts: 13 19 22 ;
	g1: new o6c4c: or: 04; t1+t3: 12; s0: 14; s1: 22; s2: 2; PAR: 0 (0); t1: 0; t2: 14; t3: 12; t4: 10; opc2f: 1; o_op2f: 1; t4f: 10 8 6 0; c: 0 11 8 6; a: 0 17 16 14; o_comps: 5 2; o_morecomps: 1 0 1; mod5: 0; mod6: 1; orverts: 2 3 6 17 ;
	может


or = 0:
t2		-2- было:  ребро poor, обе вершины unoriented
			стало: совпадающие тройки разнонаправленны
t4		-4- было:  ребро rich, обе вершины unoriented
			стало: противоположности сонаправленны

в or = 0:
	t4f[0] = 0
	то есть не бывает 3 poor ребра вместе в одной вершине
	24.05
	но на 22.05 ломается


что будет, если оставить только рёбра t2+t4
24.05
самый большой t1+t3
g13: new o6c4c: or: 11; t1+t3: 30; s0: 16; s1: 29; s2: 2; PAR: 1 (1); t1: 3; t2: 4; t3: 27; t4: 2; opc2f: 1; o_op2f: 2; t4f: 20 4 0 0; c: 0 0 12 4; a: 6 8 42 0; o_comps: 6 1; o_morecomps: 1 3 1; mod5: 0; mod6: 0; orverts: 3 6 7 9 11 12 14 16 19 20 22 ;

0:   8(e2)
1:  13(e5)
2:  18(e6)
4:   5(e14)
5:   4(e14)
8:   0(e2)
10: 15(e25)
13:  1(e5)
15: 10(e25)
18:  2(e6)
21: 23(e34)
23: 21(e34)
цикла здесь нет, здесь вообще matching остался






!!!
кстати
возьмём o6c4c
и посмотрим на 2 цепи совпадающих полностью из poor рёбер
и пускай ещё циклы в разные стороны ориентированы
	(слишком много если получилось, ну ладно)
тогда я получаю локально ситуацию or=0, s0 чётно (2 цепи), s1 чётно (равно 0)
	и ещё это немного модель того, что or=1 не сделаешь, потому что
	антиориентация последней вершины просто зафорсится
	было бы прикольно это развернуть в настоящее доказательство, но как
	как, имея n-1 неориентированную вершину, добить последнюю?

	по идее даже кажется, что достаточно узнать про ориентированность вершин
	на любом остовном дереве минус вершины на листьях (но не все)
		(ну типа мы можем выкинуть вершину с листа, если при добавлении 1 ребра с нею получаем цикл)
	а в остальных вершинах должно бы зафорситься
	но я не знаю, как такое проверить
		рандомные кейсы проверить понятно как
		все возможные деревья - непонятно
	хотя!
		я скорее всего неправ
		в плане что в различных o6c4c для одного и того же графа
		может быть и 0, и 2 or вершины
	хорошо, а если зафиксировать o6c4c?
		тогда я знаю как строится дифф


or = 0:
	давайте следить за цепями
	добавлять их по очереди
	и смотреть за тем, как меняются s0 и s1
	s0 - я добавляю по очереди цепи
	s1 - буду менять, как только я понял про ребро, что оно rich


done:
	сколько слоёв нужно, чтоб понять про все вершины - or или не or?
	3 не хватит
	4 хватит

done:
	o244-flows
	есть ли связь какая с oriented вершинами?
	почему такой вопрос - для 244-flows нужно 3 слоя
		а для определения всех or вершин - надо 4

	для o244-flows нужно что-то большее
		при этом у нас есть 10 разных вариантов сделать 244-flows
		и непонятно что там с ориентированностью
		и я даже статистику никакую не делал

	в случае or=0, 22.05: число решений o244 бывает 0, 1, 4, 5, 6
	не вижу смысла копать глубже

	o244 мне кажется неестественной конструкцией, если честно


done:
	у меня ощущение,
	что можно гипотезу перенести на дизайны
	я тут встретил дизайн для игры в крестики-нолики
	где каждая вершина лежит на 3 прямых, на каждой прямой 3 точки
		всего 9 точек, 9 прямых
		я так понимаю это ещё называется конечной проективной геометрией

		и диазйн выглядит безмостовым
		а что это значит? будем считать, что рёбра - это прямые,
			и что мост - это ребро, через которое не проходит циклов
		что такое цикл?
			набор прямых, на каждой из которых 2 вершины покрыты 2 раза, 1 вершина покрыта 1 раз
	как выясняется - это не проективный пример - тут не n^2+n+1 число точек

	хотя я даже на этом примере не проверил гипотезу

	кажется это называется steiner triple systems

	не, нету
	на fano plane не получается построить так покрытия
		там все циклы из 3 рёбер
		а покрыть надо дважды 7 рёбер
		нереально
		
	или надо менять количество циклов в покрытии
		например 3 (типа можно даже попробовать тогда
			для каждой вершины - (каждую пару рёбер + каждое ребро как висячее)
			тогда каждая вершина должна быть висячей ровно 3 раза)
		(получится минимум 6 циклов)
		(и ориентацию не накинешь, наверно)
	или понятие цикла

	берж-фалкерсона тоже наивно так нет
		как минимум надо требовать, чтоб число прямых/рёбер делилось на 3


todo:
	скачать не-снарков из базы hog
	глянуть для них or=0 решения, где не все рёбра poor
		а в таких случаях s0 чётно, s1 = 0
		тоже прокатывает, найс

todo:
	возьмём 2 разных o6c4c, но чтоб набор or вершин совпал
	может можно что-то общее вытащить отсюда?

todo:
	в идеале было бы классно сделать интерактивную штуку в вебе
	где я выкладываю что-нибудь новое про графы
	типа, решения с or = 0
	и выкладываю несколько примеров решений
	и можно на них смотреть глазами
	в данном случае, например, имеет смысл рисовать 6 копий
	наводишь мышкой на вершину - она выделяется на всех копиях
	вершины выложены по dominating circuit
		или же иметь возможность перерисовать вершины по цепях одной из копий
	рёбра помечены как rich и poor
	в общем, как я люблю рисовать в тетрадках

	ну или хотя бы написать по-быстрому генератор картинок в graphviz

хм
steiner triple system требует, что для любой пары вершин найдётся третья, с которой они образуют тройку
	это неправда для доски для игры в крестики-нолики
	которую я видел
	но её дизайн мне всё равно кажется уместным


я построил 7c3c для fano plane, гуд
	(дуальный граф - тоже fano plane
	и это решение и там, и там прокатывает одновременно)
	по ходу я не смогу определить ориентацию, потому что даже непонятно, как её вводить
	но
	у неё кажется есть аналог
	в том смысле, что можно попросить, чтоб
	на каждой прямой каждая из точек ровно 1 раз была в цикле покрыта 1 раз (а не 2)
		назовём это мидл-поинт
	хотя это условие я и так требую


так
- такие гиперграфы называются 3-uniform 3-regular
- я так понимаю число вершин равно числу рёбер
- тогда число слоёв минимум 5, потому что в одном слое максимум 2/3 e, а надо суммарно 3e
- если и есть аналог berge-fulkerson, то он будет чётный (4-cover, 6-cover, ...)
	и понадобится какое-то условие, в духе, что
	каждое ребро лежит на каком-нибудь perfect matching'е
	я за 6-cover, кстати
- у такого графа есть дуальный, где вершины заменяются на рёбра, и наоборот
	по-моему у него то же самое решение будет?
	не, выясняется, что в дуальном графе цикл может испортиться
	и одна и та же свободная вершина будет на 2 прямых лежать одновременно
	тут получается надо:
	- или наложить ограничение на циклы в исходном графе (и тогда понятно, что такой класс замкнут)
	- или расширить понятие цикла, чтоб включало и такие кейсы (и вроде тогда класс будет замкнут)
	- или продолжать жить ни так, ни так
	мне больше всего нравится вариант с расширением, но я попробую оба
		если брать вариант с расширением,
		то такое ощущение, что я могу взять в плоскости фано тупо все рёбра
		не, не могу, только если свободные вершины будут также иногда совпадать с двойными
		но в любом случае появятся циклы длины 4
      .

   .     .
     4.
 1    3
.  2  .     .
		вот такой цикл
- Fact 2.1. For any 3-uniform hypergraph H the following two inequalities hold: ∆(H) ≤ χ′(H) ≤ 3∆(H) − 2
	7 цветов хватит

- так что в теории можно было бы даже усилить требование на циклы
	типа чтобы и в дуальном графе это тоже были циклы

- когда буду писать acknowledgement
	надо будем упомянуть /r/math - за пост про топологические крестики-нолики, который у меня так и не открылся
	за гугл, который по этому запросу показал пост с доской про крестики-нолики на math.stackexchange
	и ещё тут участвует логика самой игры
	чтоб выиграть в ней или не проиграть
	там бывает серия цугцвангов
	и типа она немного напоминает цикл, если всё в ничью скатывается
	фактически - спасибо роскомнадзору

от 3 до 7 цветов в рёберной раскраске
а в вершинной? тоже
надо поизучать будет зависимость числа слоёв в [b]c3c от этих двух параметров
	b - balanced

v\e 3 4 5 6 7
3 :
4 :
5 :
6 :
7 :


как имплементить?
- базовый код перебора графов можно взять из graham-haggkvist гипотезы
- дальше нужно сгенерить все циклы - тут нужна модификация кода из cycles.h
	заодно посчитаю число циклов
	вдруг тут степень тройки вылезет, например
	и я смогу понять - какое из определений для цикла надо брать

	как генерить цикл?
	в графах я перебирал следующую вершину кажется, и брал нужное ребро
	а теперь у каждой вершины будет до 6 соседей
	и впрочем это неизбежно
	возьму за формальное определение такое:
		- на каждом ребре из цикла - 2 двойных вершины, 1 свободная
		- подграф из двойных вершин - цикл как в обычном графе (не обязательно связный)
		- множество свободных вершин и множество двойных - не пересекаются
- дальше проверяю, что каждое из рёбер лежит хотя бы на одном цикле
- дальше уже строю покрытие

21=4+4+4+3+3+3
значит fano plane меньше чем в 6 циклов не покроешь энивей




гиперграфы, код
assert: m == n
- рёбра
	edge_index
	third
		буду считать, что по паре вершин можно восстановить не более одной другой третьей
- вершины
	deg
		должно быть везде 3
	v2v: n, 3, 2
- рёбра/вершины
	v2e: n, 3
	e2v: m, 3
- циклы
	храню список рёбер
	и список свободных вершин


план
- пишу сбалансированное тройное накрытие
	separate_circuits_length_in_bc3c[layer][circuit_in_layer]
	vertex_in_bc3c[layer][v]
	edge_in_bc3c[e][j]
	edge_in_layer[layer][e]
	edge_free_vertex[layer][e]
	number_of_circuits_in_bc3c[layer]
	vertex_count_in_bc3c[v]
	multiset<int> free_vertices[layer]
	edge_count_in_bc3c[e]
	edge_pair_count_in_bc3c[e1][e2]
	total_edge_count_in_bc3c
вроде бы код показывает, что всегда есть накрытия
надо теперь порисовать эти накрытия, наверняка там бага (потому что мне часто показывается, что есть накрытия в 3 слоя, на 7 вершинах)


нашлись графы на 10 вершинах без решений
Printing graph:
0:	2_7 (e0)	3_5 (e1)	4_6 (e2)
1:	2_5 (e3)	4_9 (e4)	6_8 (e5)
2:	0_7 (e0)	1_5 (e3)	8_9 (e6)
3:	0_5 (e1)	4_8 (e7)	7_9 (e8)
4:	0_6 (e2)	1_9 (e4)	3_8 (e7)
5:	0_3 (e1)	1_2 (e3)	6_7 (e9)
6:	0_4 (e2)	1_8 (e5)	5_7 (e9)
7:	0_2 (e0)	3_9 (e8)	5_6 (e9)
8:	1_6 (e5)	2_9 (e6)	3_4 (e7)
9:	1_4 (e4)	2_8 (e6)	3_7 (e8)

Printing graph:
0:	1_5 (e0)	3_4 (e1)	7_8 (e2)
1:	0_5 (e0)	2_4 (e3)	6_9 (e4)
2:	1_4 (e3)	5_9 (e5)	6_7 (e6)
3:	0_4 (e1)	6_8 (e7)	7_9 (e8)
4:	0_3 (e1)	1_2 (e3)	5_8 (e9)
5:	0_1 (e0)	2_9 (e5)	4_8 (e9)
6:	1_9 (e4)	2_7 (e6)	3_8 (e7)
7:	0_8 (e2)	2_6 (e6)	3_9 (e8)
8:	0_7 (e2)	3_6 (e7)	4_5 (e9)
9:	1_6 (e4)	2_5 (e5)	3_7 (e8)

на 9 вершинах я такого не наблюдаю



0:  2_9 (e0)  3_4 (e1)  5_7 (e2)
1:  3_5 (e3)  6_7 (e4)  8_9 (e5)
2:  0_9 (e0)  3_8 (e6)  4_7 (e7)
3:  0_4 (e1)  1_5 (e3)  2_8 (e6)
4:  0_3 (e1)  2_7 (e7)  6_9 (e8)
5:  0_7 (e2)  1_3 (e3)  6_8 (e9)
6:  1_7 (e4)  4_9 (e8)  5_8 (e9)
7:  0_5 (e2)  1_6 (e4)  2_4 (e7)
8:  1_9 (e5)  2_3 (e6)  5_6 (e9)
9:  0_2 (e0)  1_8 (e5)  4_6 (e8)
тут и 15 слоёв не хватает вроде как



можно убрать, конечно, требование, что свободные вершины на входят в цикл
	наверно тогда это всё решается и интересно тогда найти наименьшее число слоёв
так
пока что всегда хватает 3 слоёв
i wonder - на скольки вершинах я найду сложный гиперграф
для начала надо найти негамильтоновый граф
не нашёл
ладно, забью
вообще я вручную могу построить граф, который с мостом, и который негамильтонов
0 1 2
0 3 4
0 5 6
1 7 8
1 9 10
2 11 12
2 13 14
теперь, вершины 3,4,5,6:
3 5 15
3 6 16
4 5 16
3 6 15
15 16 .

хм
давай так
раз число рёбер совпадает с числом вершин
то по идее есть matching
	ребро - вершина
так или нет?
